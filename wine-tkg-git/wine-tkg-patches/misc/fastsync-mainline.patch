From 2e261c391b17a9175ae521a233b139982351d4bb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 11:19:08 -0600
Subject: [PATCH] server: Do not allow selecting on the ifchange object.

We never pass a handle to this object to the client anyway.
---
 server/sock.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/sock.c b/server/sock.c
index 3aed5494612..8ab7d5b7236 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1536,7 +1536,7 @@ static const struct object_ops ifchange_ops =
     sizeof(struct ifchange), /* size */
     &no_type,                /* type */
     ifchange_dump,           /* dump */
-    add_queue,               /* add_queue */
+    no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
     no_satisfied,            /* satisfied */
-- 
2.11.4.GIT

From cdef21d5dfceee94811144957f1501db17f88c31 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 14:18:50 -0600
Subject: [PATCH] server: Make pulse_event() static.

---
 server/event.c  | 2 +-
 server/object.h | 1 -
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/server/event.c b/server/event.c
index c45c093e9d3..ccdd465dd5b 100644
--- a/server/event.c
+++ b/server/event.c
@@ -160,7 +160,7 @@ struct event *get_event_obj( struct process *process, obj_handle_t handle, unsig
     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
 }
 
-void pulse_event( struct event *event )
+static void pulse_event( struct event *event )
 {
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
diff --git a/server/object.h b/server/object.h
index 5b2c309f0b2..1aef43018b2 100644
--- a/server/object.h
+++ b/server/object.h
@@ -215,7 +215,6 @@ extern struct keyed_event *create_keyed_event( struct object *root, const struct
                                                unsigned int attr, const struct security_descriptor *sd );
 extern struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access );
 extern struct keyed_event *get_keyed_event_obj( struct process *process, obj_handle_t handle, unsigned int access );
-extern void pulse_event( struct event *event );
 extern void set_event( struct event *event );
 extern void reset_event( struct event *event );
 
-- 
2.11.4.GIT

From f28ddd10894f3b18e4d5d94f286eaa62ad678839 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:35:11 -0600
Subject: [PATCH] server: Use default_fd_signaled() for sockets.

---
 server/sock.c | 15 +--------------
 1 file changed, 1 insertion(+), 14 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 8ab7d5b7236..775ec6edf32 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -163,7 +163,6 @@ struct sock
 };
 
 static void sock_dump( struct object *obj, int verbose );
-static int sock_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *sock_get_fd( struct object *obj );
 static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void sock_destroy( struct object *obj );
@@ -189,7 +188,7 @@ static const struct object_ops sock_ops =
     sock_dump,                    /* dump */
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
-    sock_signaled,                /* signaled */
+    default_fd_signaled,          /* signaled */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
@@ -773,10 +772,6 @@ static void sock_poll_event( struct fd *fd, int event )
     event = sock_dispatch_asyncs( sock, event, error );
     sock_dispatch_events( sock, prevstate, event, error );
 
-    /* if anyone is stupid enough to wait on the socket object itself,
-     * maybe we should wake them up too, just in case? */
-    wake_up( &sock->obj, 0 );
-
     sock_reselect( sock );
 }
 
@@ -789,14 +784,6 @@ static void sock_dump( struct object *obj, int verbose )
             sock->mask, sock->pmask, sock->hmask );
 }
 
-static int sock_signaled( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct sock *sock = (struct sock *)obj;
-    assert( obj->ops == &sock_ops );
-
-    return check_fd_events( sock->fd, sock_get_poll_events( sock->fd ) ) != 0;
-}
-
 static int sock_get_poll_events( struct fd *fd )
 {
     struct sock *sock = get_fd_user( fd );
-- 
2.11.4.GIT

From bacf30595cecc2193733783a535b14d4fe884a17 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 16:55:41 -0600
Subject: [PATCH] server: Fix a copy-paste error in a comment.

---
 server/protocol.def | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/protocol.def b/server/protocol.def
index 7f3b785df51..51e39b5f09a 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -668,7 +668,7 @@ typedef union
     } map_view;
     struct
     {
-        enum apc_type    type;      /* APC_MAP_VIEW */
+        enum apc_type    type;      /* APC_UNMAP_VIEW */
         unsigned int     status;    /* status returned by call */
     } unmap_view;
     struct
-- 
2.11.4.GIT

From 435348c78e1b5ef83e1b306c4c986b1bd8fe7390 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 17:25:56 -0600
Subject: [PATCH] server: Remove a no longer relevant "see below" from a
 comment.

---
 server/protocol.def | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/protocol.def b/server/protocol.def
index 51e39b5f09a..86a5b6a1942 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1116,7 +1116,7 @@ typedef struct
     obj_handle_t dst_process;  /* dst process handle */
     unsigned int access;       /* wanted access rights */
     unsigned int attributes;   /* object attributes */
-    unsigned int options;      /* duplicate options (see below) */
+    unsigned int options;      /* duplicate options */
 @REPLY
     obj_handle_t handle;       /* duplicated handle in dst process */
     int          self;         /* is the source the current process? */
-- 
2.11.4.GIT

From 83b7a2a713b322e6c260c66cd2962e57b08aad11 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 9 Mar 2021 12:08:29 -0600
Subject: [PATCH] ntdll: Add some traces to synchronization methods.

---
 dlls/ntdll/unix/sync.c | 65 +++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 64 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 16635ee42fa..6e08e59174f 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -202,6 +202,14 @@ static BOOL compare_addr( const void *addr, const void *cmp, SIZE_T size )
 }
 
 
+static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
+{
+    if (!timeout) return "<infinite>";
+    return wine_dbg_sprintf( "%ld.%07ld", (long)timeout->QuadPart / TICKSPERSEC,
+                             (long)timeout->QuadPart % TICKSPERSEC );
+}
+
+
 /* create a struct security_descriptor and contained information in one contiguous piece of memory */
 NTSTATUS alloc_object_attributes( const OBJECT_ATTRIBUTES *attr, struct object_attributes **ret,
                                   data_size_t *ret_len )
@@ -319,6 +327,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, initial %d, max %d\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", initial, max );
+
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -345,6 +356,8 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 {
     NTSTATUS ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_semaphore )
@@ -403,6 +416,8 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, count %u, prev_count %p\n", handle, count, previous );
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -427,6 +442,9 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u, state %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
+
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -453,6 +471,8 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     NTSTATUS ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_event )
@@ -477,6 +497,8 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -496,6 +518,8 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -525,6 +549,8 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -582,6 +608,9 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, owned %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_mutex )
@@ -606,6 +635,8 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
 {
     NTSTATUS ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_mutex )
@@ -630,6 +661,8 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1277,6 +1310,9 @@ NTSTATUS WINAPI NtCreateTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
+
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
 
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -1304,6 +1340,8 @@ NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     NTSTATUS ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_timer )
@@ -1356,6 +1394,8 @@ NTSTATUS WINAPI NtCancelTimer( HANDLE handle, BOOLEAN *state )
 {
     NTSTATUS ret;
 
+    TRACE( "handle %p, state %p\n", handle, state );
+
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1424,13 +1464,23 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 {
     select_op_t select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
+    if (TRACE_ON(sync))
+    {
+        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
+        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
+        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
+    ret = server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
+    TRACE( "-> %#x\n", ret );
+    return ret;
 }
 
 
@@ -1452,6 +1502,8 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
+
     if (!signal) return STATUS_INVALID_HANDLE;
 
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1481,6 +1533,8 @@ NTSTATUS WINAPI NtYieldExecution(void)
  */
 NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
+    TRACE( "alertable %u, timeout %s\n", alertable, debugstr_timeout(timeout) );
+
     /* if alertable, we need to query the server */
     if (alertable) return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
 
@@ -1651,6 +1705,9 @@ NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, flags %#x\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", flags );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_keyed_event )
@@ -1674,6 +1731,8 @@ NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJE
 {
     NTSTATUS ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_keyed_event )
@@ -1699,6 +1758,8 @@ NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1718,6 +1779,8 @@ NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
-- 
2.11.4.GIT

From 6f222ab117d753aac13863aceb8f4956db056ade Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 11 Mar 2021 15:41:19 -0600
Subject: [PATCH] server: Cancel asyncs before closing handles when a process
 is destroyed.

test_exit_process_async() essentially validates this. The only reason it currently succeeds (instead of incorrectly returning ERROR_BROKEN_PIPE) is that due to the use of DuplicateHandle() the source handle is never actually closed.
---
 server/process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index f65d7abe2af..571a80f0dc6 100644
--- a/server/process.c
+++ b/server/process.c
@@ -842,8 +842,8 @@ static void process_killed( struct process *process )
     if (!process->is_system) close_process_desktop( process );
     process->winstation = 0;
     process->desktop = 0;
-    close_process_handles( process );
     cancel_process_asyncs( process );
+    close_process_handles( process );
     if (process->idle_event) release_object( process->idle_event );
     process->idle_event = NULL;
     assert( !process->console );
-- 
2.11.4.GIT

From cbba08ab81f4bf860d84775a8e0d0e6289e19a0e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 17:42:18 -0600
Subject: [PATCH] ntdll: Use a kernel APC to call NtDuplicateObject() if
 DUPLICATE_CLOSE_SOURCE is used on another process.

---
 dlls/ntdll/unix/server.c | 36 ++++++++++++++++++++++++++++++++++++
 server/protocol.def      | 16 ++++++++++++++++
 server/thread.c          | 15 +++++++++++++++
 server/trace.c           |  9 +++++++++
 4 files changed, 76 insertions(+)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 4f149c0f644..1f8cf546977 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -580,6 +580,21 @@ static void invoke_system_apc( const apc_call_t *call, apc_result_t *result )
         else result->create_thread.status = STATUS_INVALID_PARAMETER;
         break;
     }
+    case APC_DUP_HANDLE:
+    {
+        HANDLE dst_handle = NULL;
+
+        result->type = call->type;
+
+        result->dup_handle.status = NtDuplicateObject( NtCurrentProcess(),
+                                                       wine_server_ptr_handle(call->dup_handle.src_handle),
+                                                       wine_server_ptr_handle(call->dup_handle.dst_process),
+                                                       &dst_handle, call->dup_handle.access,
+                                                       call->dup_handle.attributes, call->dup_handle.options );
+        result->dup_handle.handle = wine_server_obj_handle( dst_handle );
+        NtClose( wine_server_ptr_handle(call->dup_handle.dst_process) );
+        break;
+    }
     case APC_BREAK_PROCESS:
     {
         HANDLE handle;
@@ -1679,6 +1694,27 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
 {
     NTSTATUS ret;
 
+    if ((options & DUPLICATE_CLOSE_SOURCE) && source_process != NtCurrentProcess())
+    {
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.dup_handle.type        = APC_DUP_HANDLE;
+        call.dup_handle.src_handle  = wine_server_obj_handle( source );
+        call.dup_handle.dst_process = wine_server_obj_handle( dest_process );
+        call.dup_handle.access      = access;
+        call.dup_handle.attributes  = attributes;
+        call.dup_handle.options     = options;
+        ret = server_queue_process_apc( source_process, &call, &result );
+        if (ret != STATUS_SUCCESS) return ret;
+
+        if (!result.dup_handle.status)
+            *dest = wine_server_ptr_handle( result.dup_handle.handle );
+        return result.dup_handle.status;
+    }
+
     SERVER_START_REQ( dup_handle )
     {
         req->src_process = wine_server_obj_handle( source_process );
diff --git a/server/protocol.def b/server/protocol.def
index 86a5b6a1942..4138d4be840 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -483,6 +483,7 @@ enum apc_type
     APC_MAP_VIEW,
     APC_UNMAP_VIEW,
     APC_CREATE_THREAD,
+    APC_DUP_HANDLE,
     APC_BREAK_PROCESS
 };
 
@@ -593,6 +594,15 @@ typedef union
         mem_size_t       reserve;   /* reserve size for thread stack */
         mem_size_t       commit;    /* commit size for thread stack */
     } create_thread;
+    struct
+    {
+        enum apc_type    type;         /* APC_DUP_HANDLE */
+        obj_handle_t     src_handle;   /* src handle to duplicate */
+        obj_handle_t     dst_process;  /* dst process handle */
+        unsigned int     access;       /* wanted access rights */
+        unsigned int     attributes;   /* object attributes */
+        unsigned int     options;      /* duplicate options */
+    } dup_handle;
 } apc_call_t;
 
 typedef union
@@ -682,6 +692,12 @@ typedef union
     } create_thread;
     struct
     {
+        enum apc_type    type;      /* APC_DUP_HANDLE */
+        unsigned int     status;    /* status returned by call */
+        obj_handle_t     handle;    /* duplicated handle in dst process */
+    } dup_handle;
+    struct
+    {
         enum apc_type    type;      /* APC_BREAK_PROCESS */
         unsigned int     status;    /* status returned by call */
     } break_process;
diff --git a/server/thread.c b/server/thread.c
index e4abe4fab94..fe9f9bdec37 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1756,6 +1756,21 @@ DECL_HANDLER(queue_apc)
     case APC_BREAK_PROCESS:
         process = get_process_from_handle( req->handle, PROCESS_CREATE_THREAD );
         break;
+    case APC_DUP_HANDLE:
+        process = get_process_from_handle( req->handle, PROCESS_DUP_HANDLE );
+        if (process && process != current->process)
+        {
+            /* duplicate the destination process handle into the target process */
+            obj_handle_t handle = duplicate_handle( current->process, apc->call.dup_handle.dst_process,
+                                                    process, 0, 0, DUPLICATE_SAME_ACCESS );
+            if (handle) apc->call.dup_handle.dst_process = handle;
+            else
+            {
+                release_object( process );
+                process = NULL;
+            }
+        }
+        break;
     default:
         set_error( STATUS_INVALID_PARAMETER );
         break;
diff --git a/server/trace.c b/server/trace.c
index b07935cc54b..f7c792b326d 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -235,6 +235,11 @@ static void dump_apc_call( const char *prefix, const apc_call_t *call )
         dump_uint64( ",commit=", &call->create_thread.commit );
         fprintf( stderr, ",flags=%x", call->create_thread.flags );
         break;
+    case APC_DUP_HANDLE:
+        fprintf( stderr, "APC_DUP_HANDLE,src_handle=%04x,dst_process=%04x,access=%x,attributes=%x,options=%x",
+                 call->dup_handle.src_handle, call->dup_handle.dst_process, call->dup_handle.access,
+                 call->dup_handle.attributes, call->dup_handle.options );
+        break;
     case APC_BREAK_PROCESS:
         fprintf( stderr, "APC_BREAK_PROCESS" );
         break;
@@ -318,6 +323,10 @@ static void dump_apc_result( const char *prefix, const apc_result_t *result )
                  get_status_name( result->create_thread.status ),
                  result->create_thread.pid, result->create_thread.tid, result->create_thread.handle );
         break;
+    case APC_DUP_HANDLE:
+        fprintf( stderr, "APC_DUP_HANDLE,status=%s,handle=%04x",
+                 get_status_name( result->dup_handle.status ), result->dup_handle.handle );
+        break;
     case APC_BREAK_PROCESS:
         fprintf( stderr, "APC_BREAK_PROCESS,status=%s", get_status_name( result->break_process.status ) );
         break;
-- 
2.11.4.GIT

From 6b7c0801e6c89c438cf8b606c5493c9bc64e6415 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 17:49:18 -0600
Subject: [PATCH] ntdll: Remove the source fd from the cache before calling the
 dup_handle request.

If another thread creates and accesses a file between the dup_handle request
and the call to remove_fd_from_cache(), the file may be allocated to the same
handle number, and that thread will then receive the wrong unix fd. Avoid this
race by invalidating the cache first.

This fixes the race mentioned here:
<https://www.winehq.org/pipermail/wine-devel/2021-January/179733.html>
---
 dlls/ntdll/unix/server.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 1f8cf546977..506cc99e542 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1693,6 +1693,7 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
                                    ACCESS_MASK access, ULONG attributes, ULONG options )
 {
     NTSTATUS ret;
+    int fd;
 
     if ((options & DUPLICATE_CLOSE_SOURCE) && source_process != NtCurrentProcess())
     {
@@ -1715,6 +1716,14 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
         return result.dup_handle.status;
     }
 
+    /* always remove the cached fd; if the server request fails we'll just
+     * retrieve it again */
+    if (options & DUPLICATE_CLOSE_SOURCE)
+    {
+        fd = remove_fd_from_cache( source );
+        if (fd != -1) close( fd );
+    }
+
     SERVER_START_REQ( dup_handle )
     {
         req->src_process = wine_server_obj_handle( source_process );
@@ -1726,11 +1735,6 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
         if (!(ret = wine_server_call( req )))
         {
             if (dest) *dest = wine_server_ptr_handle( reply->handle );
-            if (reply->closed && reply->self)
-            {
-                int fd = remove_fd_from_cache( source );
-                if (fd != -1) close( fd );
-            }
         }
     }
     SERVER_END_REQ;
@@ -1745,6 +1749,9 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
 {
     HANDLE port;
     NTSTATUS ret;
+
+    /* always remove the cached fd; if the server request fails we'll just
+     * retrieve it again */
     int fd = remove_fd_from_cache( handle );
 
     SERVER_START_REQ( close_handle )
-- 
2.11.4.GIT

From f714e28b949d68fb79954699eb70b54d23374250 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 17:52:11 -0600
Subject: [PATCH] server: Remove the no longer used self and closed fields from
 the dup_handle request.

---
 server/handle.c     | 3 +--
 server/protocol.def | 2 --
 2 files changed, 1 insertion(+), 4 deletions(-)

diff --git a/server/handle.c b/server/handle.c
index 6e0848eedf0..d86f0960ccf 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -678,8 +678,7 @@ DECL_HANDLER(dup_handle)
         }
         /* close the handle no matter what happened */
         if ((req->options & DUPLICATE_CLOSE_SOURCE) && (src != dst || req->src_handle != reply->handle))
-            reply->closed = !close_handle( src, req->src_handle );
-        reply->self = (src == current->process);
+            close_handle( src, req->src_handle );
         release_object( src );
     }
 }
diff --git a/server/protocol.def b/server/protocol.def
index 4138d4be840..a26200b4c4f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1135,8 +1135,6 @@ typedef struct
     unsigned int options;      /* duplicate options */
 @REPLY
     obj_handle_t handle;       /* duplicated handle in dst process */
-    int          self;         /* is the source the current process? */
-    int          closed;       /* whether the source handle has been closed */
 @END
 
 
-- 
2.11.4.GIT

From 7b1f72c6d52470415463ed92a8d720f9302660e0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 17:55:18 -0600
Subject: [PATCH] server: Do not forbid closing fd handles in other processes.

Since we use an APC now, we never will anyway, so the code is redundant.
---
 server/change.c     | 1 -
 server/console.c    | 2 +-
 server/file.c       | 2 +-
 server/file.h       | 1 -
 server/mailslot.c   | 6 +++---
 server/mapping.c    | 2 +-
 server/named_pipe.c | 6 +++---
 server/serial.c     | 2 +-
 server/sock.c       | 2 +-
 9 files changed, 11 insertions(+), 13 deletions(-)

diff --git a/server/change.c b/server/change.c
index ff8c3ad1037..b02a9cd65bf 100644
--- a/server/change.c
+++ b/server/change.c
@@ -421,7 +421,6 @@ static int dir_close_handle( struct object *obj, struct process *process, obj_ha
 {
     struct dir *dir = (struct dir *)obj;
 
-    if (!fd_close_handle( obj, process, handle )) return 0;
     if (obj->handle_count == 1) release_dir_cache_entry( dir ); /* closing last handle, release cache */
     return 1;  /* ok to close */
 }
diff --git a/server/console.c b/server/console.c
index 848ee6e8d98..1e6f6c0f8a3 100644
--- a/server/console.c
+++ b/server/console.c
@@ -168,7 +168,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    fd_close_handle,                  /* close_handle */
+    no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
 
diff --git a/server/file.c b/server/file.c
index f9ce0106c3b..9a072e6c64e 100644
--- a/server/file.c
+++ b/server/file.c
@@ -109,7 +109,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
-    fd_close_handle,              /* close_handle */
+    no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
 
diff --git a/server/file.h b/server/file.h
index fbfd1e4eec9..0fa66e5750a 100644
--- a/server/file.h
+++ b/server/file.h
@@ -93,7 +93,6 @@ extern int is_fd_overlapped( struct fd *fd );
 extern int get_unix_fd( struct fd *fd );
 extern int is_same_file_fd( struct fd *fd1, struct fd *fd2 );
 extern int is_fd_removable( struct fd *fd );
-extern int fd_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 extern int check_fd_events( struct fd *fd, int events );
 extern void set_fd_events( struct fd *fd, int events );
 extern obj_handle_t lock_fd( struct fd *fd, file_pos_t offset, file_pos_t count, int shared, int wait );
diff --git a/server/mailslot.c b/server/mailslot.c
index 5597a21dd29..d4b2fd1b562 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -90,7 +90,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    fd_close_handle,           /* close_handle */
+    no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
 
@@ -148,7 +148,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
-    fd_close_handle,            /* close_handle */
+    no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
 
@@ -240,7 +240,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
-    fd_close_handle,                        /* close_handle */
+    no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
 
diff --git a/server/mapping.c b/server/mapping.c
index ebf3e057c75..023dfbbef17 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -189,7 +189,7 @@ static const struct object_ops mapping_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
-    fd_close_handle,             /* close_handle */
+    no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
 
diff --git a/server/named_pipe.c b/server/named_pipe.c
index a3ce9d463f1..df8c7e3170c 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -179,7 +179,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    fd_close_handle,              /* close_handle */
+    no_close_handle,              /* close_handle */
     pipe_server_destroy           /* destroy */
 };
 
@@ -222,7 +222,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    fd_close_handle,              /* close_handle */
+    no_close_handle,              /* close_handle */
     pipe_end_destroy              /* destroy */
 };
 
@@ -299,7 +299,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    fd_close_handle,                         /* close_handle */
+    no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
 
diff --git a/server/serial.c b/server/serial.c
index ba8402c5935..d3ea4cbe420 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -104,7 +104,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    fd_close_handle,              /* close_handle */
+    no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
 
diff --git a/server/sock.c b/server/sock.c
index 775ec6edf32..00d5b0b9044 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -889,7 +889,7 @@ static int sock_close_handle( struct object *obj, struct process *process, obj_h
             async_terminate( req->async, STATUS_CANCELLED );
     }
 
-    return fd_close_handle( obj, process, handle );
+    return 1;
 }
 
 static void sock_destroy( struct object *obj )
-- 
2.11.4.GIT

From efa57fd0aadd9b888f67941f6a2054ee12acf139 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 14:31:06 -0600
Subject: [PATCH] server: Add an object operation to retrieve a fast
 synchronization object.

---
 server/async.c      |  2 ++
 server/atom.c       |  1 +
 server/change.c     |  1 +
 server/clipboard.c  |  1 +
 server/completion.c |  1 +
 server/console.c    |  7 +++++++
 server/debugger.c   |  2 ++
 server/device.c     |  4 ++++
 server/directory.c  |  2 ++
 server/event.c      |  2 ++
 server/fd.c         |  4 ++++
 server/file.c       |  1 +
 server/handle.c     |  1 +
 server/hook.c       |  1 +
 server/mailslot.c   |  4 ++++
 server/mapping.c    |  3 +++
 server/mutex.c      |  1 +
 server/named_pipe.c |  5 +++++
 server/object.c     |  6 ++++++
 server/object.h     |  7 +++++++
 server/process.c    |  3 +++
 server/protocol.def | 10 ++++++++++
 server/queue.c      |  2 ++
 server/registry.c   |  1 +
 server/request.c    |  1 +
 server/semaphore.c  |  1 +
 server/serial.c     |  1 +
 server/signal.c     |  1 +
 server/sock.c       |  3 +++
 server/symlink.c    |  1 +
 server/thread.c     |  3 +++
 server/timer.c      |  1 +
 server/token.c      |  1 +
 server/winstation.c |  2 ++
 34 files changed, 87 insertions(+)

diff --git a/server/async.c b/server/async.c
index 1ac5117edb9..fe159fef790 100644
--- a/server/async.c
+++ b/server/async.c
@@ -84,6 +84,7 @@ static const struct object_ops async_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     async_destroy              /* destroy */
 };
@@ -511,6 +512,7 @@ static const struct object_ops iosb_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     iosb_destroy              /* destroy */
 };
diff --git a/server/atom.c b/server/atom.c
index 8d0ffbb05f3..e638b064f49 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -92,6 +92,7 @@ static const struct object_ops atom_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     atom_table_destroy            /* destroy */
 };
diff --git a/server/change.c b/server/change.c
index b02a9cd65bf..55c848bfe28 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,6 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/clipboard.c b/server/clipboard.c
index 1c4875ff726..1d9369deb52 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -89,6 +89,7 @@ static const struct object_ops clipboard_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     clipboard_destroy             /* destroy */
 };
diff --git a/server/completion.c b/server/completion.c
index eb0d256ad09..b7eaa5a29bb 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -88,6 +88,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     completion_destroy         /* destroy */
 };
diff --git a/server/console.c b/server/console.c
index 1e6f6c0f8a3..d1d47a7e4bf 100644
--- a/server/console.c
+++ b/server/console.c
@@ -93,6 +93,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -168,6 +169,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -236,6 +238,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -284,6 +287,7 @@ static const struct object_ops console_device_ops =
     default_unlink_name,              /* unlink_name */
     console_device_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     no_destroy                        /* destroy */
 };
@@ -321,6 +325,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -377,6 +382,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -434,6 +440,7 @@ static const struct object_ops console_connection_ops =
     default_unlink_name,              /* unlink_name */
     console_connection_open_file,     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     console_connection_close_handle,  /* close_handle */
     console_connection_destroy        /* destroy */
 };
diff --git a/server/debugger.c b/server/debugger.c
index 2a2839f42ee..f891af48723 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -99,6 +99,7 @@ static const struct object_ops debug_event_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_event_destroy            /* destroy */
 };
@@ -127,6 +128,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 6400751e339..8e5cad82b97 100644
--- a/server/device.c
+++ b/server/device.c
@@ -80,6 +80,7 @@ static const struct object_ops irp_call_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     irp_call_destroy                  /* destroy */
 };
@@ -120,6 +121,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -177,6 +179,7 @@ static const struct object_ops device_ops =
     default_unlink_name,              /* unlink_name */
     device_open_file,                 /* open_file */
     device_get_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_destroy                    /* destroy */
 };
@@ -229,6 +232,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/directory.c b/server/directory.c
index 30d69459984..4a0ec8867f8 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -82,6 +82,7 @@ static const struct object_ops object_type_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     no_destroy                    /* destroy */
 };
@@ -132,6 +133,7 @@ static const struct object_ops directory_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     directory_destroy             /* destroy */
 };
diff --git a/server/event.c b/server/event.c
index ccdd465dd5b..c922f083e4a 100644
--- a/server/event.c
+++ b/server/event.c
@@ -84,6 +84,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     no_destroy                 /* destroy */
 };
@@ -131,6 +132,7 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     no_destroy                   /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 65a6f876e5c..3361b3b4bbe 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -224,6 +224,7 @@ static const struct object_ops fd_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     fd_destroy                /* destroy */
 };
@@ -265,6 +266,7 @@ static const struct object_ops device_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     device_destroy            /* destroy */
 };
@@ -305,6 +307,7 @@ static const struct object_ops inode_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     inode_destroy             /* destroy */
 };
@@ -347,6 +350,7 @@ static const struct object_ops file_lock_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/file.c b/server/file.c
index 9a072e6c64e..39aff28165c 100644
--- a/server/file.c
+++ b/server/file.c
@@ -109,6 +109,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/handle.c b/server/handle.c
index d86f0960ccf..6cf388cd1d5 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -138,6 +138,7 @@ static const struct object_ops handle_table_ops =
     NULL,                            /* unlink_name */
     no_open_file,                    /* open_file */
     no_kernel_obj_list,              /* get_kernel_obj_list */
+    no_get_fast_sync,                /* get_fast_sync */
     no_close_handle,                 /* close_handle */
     handle_table_destroy             /* destroy */
 };
diff --git a/server/hook.c b/server/hook.c
index c048908c295..8d1f7895313 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -93,6 +93,7 @@ static const struct object_ops hook_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     hook_table_destroy            /* destroy */
 };
diff --git a/server/mailslot.c b/server/mailslot.c
index d4b2fd1b562..1cb01307326 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -90,6 +90,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -148,6 +149,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -210,6 +212,7 @@ static const struct object_ops mailslot_device_ops =
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_fast_sync,               /* get_fast_sync */
     no_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
@@ -240,6 +243,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
+    no_get_fast_sync,                       /* get_fast_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/mapping.c b/server/mapping.c
index 023dfbbef17..6a0f5fb8980 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -80,6 +80,7 @@ static const struct object_ops ranges_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     ranges_destroy             /* destroy */
 };
@@ -116,6 +117,7 @@ static const struct object_ops shared_map_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     shared_map_destroy         /* destroy */
 };
@@ -189,6 +191,7 @@ static const struct object_ops mapping_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
diff --git a/server/mutex.c b/server/mutex.c
index 75ff5117d3f..8d3926e217f 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -85,6 +85,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index df8c7e3170c..50ead981d0e 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -131,6 +131,7 @@ static const struct object_ops named_pipe_ops =
     default_unlink_name,          /* unlink_name */
     named_pipe_open_file,         /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     named_pipe_destroy            /* destroy */
 };
@@ -179,6 +180,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -222,6 +224,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -268,6 +271,7 @@ static const struct object_ops named_pipe_device_ops =
     default_unlink_name,              /* unlink_name */
     named_pipe_device_open_file,      /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     named_pipe_device_destroy         /* destroy */
 };
@@ -299,6 +303,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_fast_sync,                        /* get_fast_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
diff --git a/server/object.c b/server/object.c
index b2779fd61fe..e8d6783537c 100644
--- a/server/object.c
+++ b/server/object.c
@@ -528,6 +528,12 @@ struct fd *no_get_fd( struct object *obj )
     return NULL;
 }
 
+struct fast_sync *no_get_fast_sync( struct object *obj )
+{
+    set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    return NULL;
+}
+
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff --git a/server/object.h b/server/object.h
index 1aef43018b2..35950dd4b31 100644
--- a/server/object.h
+++ b/server/object.h
@@ -45,6 +45,7 @@ struct async;
 struct async_queue;
 struct winstation;
 struct object_type;
+struct fast_sync;
 
 
 struct unicode_str
@@ -106,6 +107,8 @@ struct object_ops
                                 unsigned int options);
     /* return list of kernel objects */
     struct list *(*get_kernel_obj_list)(struct object *);
+    /* get a client-waitable fast-synchronization handle to this object */
+    struct fast_sync *(*get_fast_sync)(struct object *);
     /* close a handle to this object */
     int (*close_handle)(struct object *,struct process *,obj_handle_t);
     /* destroy on refcount == 0 */
@@ -222,6 +225,10 @@ extern void reset_event( struct event *event );
 
 extern void abandon_mutexes( struct thread *thread );
 
+/* fast-synchronization functions */
+
+extern struct fast_sync *no_get_fast_sync( struct object *obj );
+
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff --git a/server/process.c b/server/process.c
index 571a80f0dc6..6a869e4f7e7 100644
--- a/server/process.c
+++ b/server/process.c
@@ -103,6 +103,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -154,6 +155,7 @@ static const struct object_ops startup_info_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     startup_info_destroy           /* destroy */
 };
@@ -212,6 +214,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
diff --git a/server/protocol.def b/server/protocol.def
index a26200b4c4f..55c6ef3967f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3708,3 +3708,13 @@ struct handle_info
 @REQ(resume_process)
     obj_handle_t handle;       /* process handle */
 @END
+
+
+enum fast_sync_type
+{
+    FAST_SYNC_SEMAPHORE,
+    FAST_SYNC_MUTEX,
+    FAST_SYNC_EVENT,
+    FAST_SYNC_SERVER,
+    FAST_SYNC_QUEUE,
+};
diff --git a/server/queue.c b/server/queue.c
index e47980a4aa8..9444b6ba7f5 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -183,6 +183,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -220,6 +221,7 @@ static const struct object_ops thread_input_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     thread_input_destroy          /* destroy */
 };
diff --git a/server/registry.c b/server/registry.c
index 74da4d1d9a4..2ca5ac28be3 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -186,6 +186,7 @@ static const struct object_ops key_ops =
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_fast_sync,        /* get_fast_sync */
     key_close_handle,        /* close_handle */
     key_destroy              /* destroy */
 };
diff --git a/server/request.c b/server/request.c
index 29b63600f15..ae6d9d0b52c 100644
--- a/server/request.c
+++ b/server/request.c
@@ -109,6 +109,7 @@ static const struct object_ops master_socket_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     master_socket_destroy          /* destroy */
 };
diff --git a/server/semaphore.c b/server/semaphore.c
index 543d5883ec8..2295f2f4556 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -82,6 +82,7 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     no_destroy                     /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index d3ea4cbe420..87f6bf56b40 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -104,6 +104,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/signal.c b/server/signal.c
index 0c22c157f2b..ad555fd51af 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -79,6 +79,7 @@ static const struct object_ops handler_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     handler_destroy           /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 00d5b0b9044..48918c14a08 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -201,6 +201,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
@@ -1538,6 +1539,7 @@ static const struct object_ops ifchange_ops =
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_fast_sync,        /* get_fast_sync */
     no_close_handle,         /* close_handle */
     ifchange_destroy         /* destroy */
 };
@@ -1758,6 +1760,7 @@ static const struct object_ops socket_device_ops =
     default_unlink_name,        /* unlink_name */
     socket_device_open_file,    /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/symlink.c b/server/symlink.c
index 3879bb685f7..241e13fa369 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -84,6 +84,7 @@ static const struct object_ops symlink_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     symlink_destroy               /* destroy */
 };
diff --git a/server/thread.c b/server/thread.c
index fe9f9bdec37..0e8c711aa05 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -122,6 +122,7 @@ static const struct object_ops thread_apc_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     thread_apc_destroy          /* destroy */
 };
@@ -159,6 +160,7 @@ static const struct object_ops context_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -208,6 +210,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
diff --git a/server/timer.c b/server/timer.c
index 49483d9ae13..c6417fc9a43 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -89,6 +89,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
diff --git a/server/token.c b/server/token.c
index 089f1c5c61e..46f551e3580 100644
--- a/server/token.c
+++ b/server/token.c
@@ -173,6 +173,7 @@ static const struct object_ops token_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     token_destroy              /* destroy */
 };
diff --git a/server/winstation.c b/server/winstation.c
index 1c7552f0687..5232f6188e2 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -87,6 +87,7 @@ static const struct object_ops winstation_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     winstation_close_handle,      /* close_handle */
     winstation_destroy            /* destroy */
 };
@@ -127,6 +128,7 @@ static const struct object_ops desktop_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     desktop_close_handle,         /* close_handle */
     desktop_destroy               /* destroy */
 };
-- 
2.11.4.GIT

From 14eb174e7217c6aa6e7417f6009ee63619c94ee0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 16:38:18 -0600
Subject: [PATCH] server: Create fast synchronization objects for events.

---
 configure.ac        |   1 +
 server/Makefile.in  |   1 +
 server/event.c      |  27 ++++-
 server/fast_sync.c  | 276 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 server/object.h     |   4 +
 server/protocol.def |   2 +-
 6 files changed, 308 insertions(+), 3 deletions(-)
 create mode 100644 server/fast_sync.c

diff --git a/configure.ac b/configure.ac
index 1ca832102d8..534c7c2d965 100644
--- a/configure.ac
+++ b/configure.ac
@@ -472,6 +472,7 @@ AC_CHECK_HEADERS(\
 	linux/serial.h \
 	linux/types.h \
 	linux/ucdrom.h \
+	linux/winesync.h \
 	lwp.h \
 	mach-o/loader.h \
 	mach/mach.h \
diff --git a/server/Makefile.in b/server/Makefile.in
index 4264e3db108..7486ef5010d 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -12,6 +12,7 @@ C_SRCS = \
 	device.c \
 	directory.c \
 	event.c \
+	fast_sync.c \
 	fd.c \
 	file.c \
 	handle.c \
diff --git a/server/event.c b/server/event.c
index c922f083e4a..dfaec131f09 100644
--- a/server/event.c
+++ b/server/event.c
@@ -56,6 +56,7 @@ struct event
     struct list    kernel_object;   /* list of kernel object pointers */
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void event_dump( struct object *obj, int verbose );
@@ -63,6 +64,8 @@ static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *event_get_fast_sync( struct object *obj );
+static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
 {
@@ -84,9 +87,9 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    event_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
-    no_destroy                 /* destroy */
+    event_destroy              /* destroy */
 };
 
 
@@ -152,6 +155,7 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             list_init( &event->kernel_object );
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
+            event->fast_sync    = NULL;
         }
     }
     return event;
@@ -175,11 +179,13 @@ void set_event( struct event *event )
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
+    fast_set_event( event->fast_sync );
 }
 
 void reset_event( struct event *event )
 {
     event->signaled = 0;
+    fast_reset_event( event->fast_sync );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -225,6 +231,23 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
     return &event->kernel_object;
 }
 
+static struct fast_sync *event_get_fast_sync( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (!event->fast_sync)
+        event->fast_sync = fast_create_event( FAST_SYNC_EVENT, event->manual_reset, event->signaled );
+    if (event->fast_sync) grab_object( event->fast_sync );
+    return event->fast_sync;
+}
+
+static void event_destroy( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (event->fast_sync) release_object( event->fast_sync );
+}
+
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
                                         unsigned int attr, const struct security_descriptor *sd )
 {
diff --git a/server/fast_sync.c b/server/fast_sync.c
new file mode 100644
index 00000000000..4635e0b3751
--- /dev/null
+++ b/server/fast_sync.c
@@ -0,0 +1,276 @@
+/*
+ * Fast synchronization primitives
+ *
+ * Copyright (C) 2021 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <fcntl.h>
+#ifdef HAVE_LINUX_WINESYNC_H
+# include <linux/winesync.h>
+#endif
+#include <stdio.h>
+#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+
+#include "file.h"
+#include "thread.h"
+
+#ifdef HAVE_LINUX_WINESYNC_H
+
+struct fast_sync_device
+{
+    struct object obj;      /* object header */
+    struct fd *fd;          /* fd for unix fd */
+};
+
+static struct fast_sync_device *fast_sync_device_object;
+
+static void fast_sync_device_dump( struct object *obj, int verbose );
+static struct fd *fast_sync_device_get_fd( struct object *obj );
+static void fast_sync_device_destroy( struct object *obj );
+static enum server_fd_type fast_sync_device_get_fd_type( struct fd *fd );
+
+static const struct object_ops fast_sync_device_ops =
+{
+    sizeof(struct fast_sync_device),    /* size */
+    &no_type,                           /* type */
+    fast_sync_device_dump,              /* dump */
+    no_add_queue,                       /* add_queue */
+    NULL,                               /* remove_queue */
+    NULL,                               /* signaled */
+    NULL,                               /* satisfied */
+    no_signal,                          /* signal */
+    fast_sync_device_get_fd,            /* get_fd */
+    default_map_access,                 /* map_access */
+    default_get_sd,                     /* get_sd */
+    default_set_sd,                     /* set_sd */
+    no_get_full_name,                   /* get_full_name */
+    no_lookup_name,                     /* lookup_name */
+    no_link_name,                       /* link_name */
+    NULL,                               /* unlink_name */
+    no_open_file,                       /* open_file */
+    no_kernel_obj_list,                 /* get_kernel_obj_list */
+    no_get_fast_sync,                   /* get_fast_sync */
+    no_close_handle,                    /* close_handle */
+    fast_sync_device_destroy            /* destroy */
+};
+
+static const struct fd_ops fast_sync_device_fd_ops =
+{
+    default_fd_get_poll_events,     /* get_poll_events */
+    default_poll_event,             /* poll_event */
+    fast_sync_device_get_fd_type,   /* get_fd_type */
+    no_fd_read,                     /* read */
+    no_fd_write,                    /* write */
+    no_fd_flush,                    /* flush */
+    no_fd_get_file_info,            /* get_file_info */
+    no_fd_get_volume_info,          /* get_volume_info */
+    no_fd_ioctl,                    /* ioctl */
+    no_fd_queue_async,              /* queue_async */
+    default_fd_reselect_async       /* reselect_async */
+};
+
+static void fast_sync_device_dump( struct object *obj, int verbose )
+{
+    struct fast_sync_device *device = (struct fast_sync_device *)obj;
+    assert( obj->ops == &fast_sync_device_ops );
+    fprintf( stderr, "Fast synchronization device fd=%p\n", device->fd );
+}
+
+static struct fd *fast_sync_device_get_fd( struct object *obj )
+{
+    struct fast_sync_device *device = (struct fast_sync_device *)obj;
+    return (struct fd *)grab_object( device->fd );
+}
+
+static void fast_sync_device_destroy( struct object *obj )
+{
+    struct fast_sync_device *device = (struct fast_sync_device *)obj;
+    assert( obj->ops == &fast_sync_device_ops );
+    if (device->fd) release_object( device->fd );
+    fast_sync_device_object = NULL;
+}
+
+static enum server_fd_type fast_sync_device_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_FILE;
+}
+
+static struct fast_sync_device *get_fast_sync_device(void)
+{
+    struct fast_sync_device *device;
+    int unix_fd;
+
+    if (fast_sync_device_object)
+        return (struct fast_sync_device *)grab_object( fast_sync_device_object );
+
+    unix_fd = open( "/dev/winesync", O_CLOEXEC | O_RDONLY );
+    if (unix_fd == -1)
+    {
+        file_set_error();
+        return NULL;
+    }
+
+    if (!(device = alloc_object( &fast_sync_device_ops )))
+    {
+        close( unix_fd );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    if (!(device->fd = create_anonymous_fd( &fast_sync_device_fd_ops, unix_fd, &device->obj, 0 )))
+    {
+        release_object( device );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    fast_sync_device_object = device;
+    return device;
+}
+
+struct fast_sync
+{
+    struct object obj;
+    struct fast_sync_device *device;
+    enum fast_sync_type type;
+    int linux_obj;
+};
+
+static void fast_sync_dump( struct object *obj, int verbose );
+static void fast_sync_destroy( struct object *obj );
+
+static const struct object_ops fast_sync_ops =
+{
+    sizeof(struct fast_sync),   /* size */
+    &no_type,                   /* type */
+    fast_sync_dump,             /* dump */
+    no_add_queue,               /* add_queue */
+    NULL,                       /* remove_queue */
+    NULL,                       /* signaled */
+    NULL,                       /* satisfied */
+    no_signal,                  /* signal */
+    no_get_fd,                  /* get_fd */
+    default_map_access,         /* map_access */
+    default_get_sd,             /* get_sd */
+    default_set_sd,             /* set_sd */
+    no_get_full_name,           /* get_full_name */
+    no_lookup_name,             /* lookup_name */
+    no_link_name,               /* link_name */
+    NULL,                       /* unlink_name */
+    no_open_file,               /* open_file */
+    no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
+    no_close_handle,            /* close_handle */
+    fast_sync_destroy           /* destroy */
+};
+
+static void fast_sync_dump( struct object *obj, int verbose )
+{
+    struct fast_sync *fast_sync = (struct fast_sync *)obj;
+    assert( obj->ops == &fast_sync_ops );
+    fprintf( stderr, "Fast synchronization object type=%u linux_obj=%d\n",
+             fast_sync->type, fast_sync->linux_obj );
+}
+
+static void fast_sync_destroy( struct object *obj )
+{
+    struct fast_sync *fast_sync = (struct fast_sync *)obj;
+
+    if (fast_sync->linux_obj >= 0)
+        ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_DELETE, &fast_sync->linux_obj );
+    release_object( fast_sync->device );
+}
+
+struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled )
+{
+    struct winesync_sem_args args = {0};
+    struct fast_sync_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_fast_sync_device())) return NULL;
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    fast_sync->device = device;
+    fast_sync->type = type;
+    fast_sync->linux_obj = -1;
+
+    args.count = signaled;
+    args.max = 1;
+    if (!manual_reset)
+        args.flags |= WINESYNC_SEM_GETONWAIT;
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_SEM, &args ) < 0)
+    {
+        file_set_error();
+        release_object( fast_sync );
+        return NULL;
+    }
+    fast_sync->linux_obj = args.sem;
+
+    return fast_sync;
+}
+
+void fast_set_event( struct fast_sync *fast_sync )
+{
+    struct winesync_sem_args args = {0};
+
+    if (!fast_sync) return;
+
+    if (debug_level) fprintf( stderr, "fast_set_event %d\n", fast_sync->linux_obj );
+
+    args.sem = fast_sync->linux_obj;
+    args.count = 1;
+    ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_PUT_SEM, &args );
+}
+
+void fast_reset_event( struct fast_sync *fast_sync )
+{
+    if (!fast_sync) return;
+
+    if (debug_level) fprintf( stderr, "fast_reset_event %d\n", fast_sync->linux_obj );
+
+    ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_GET_SEM, &fast_sync->linux_obj );
+}
+
+#else
+
+struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
+void fast_set_event( struct fast_sync *fast_sync )
+{
+}
+
+void fast_reset_event( struct fast_sync *obj )
+{
+}
+
+#endif
diff --git a/server/object.h b/server/object.h
index 35950dd4b31..f98e4a73a08 100644
--- a/server/object.h
+++ b/server/object.h
@@ -227,6 +227,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 /* fast-synchronization functions */
 
+extern struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled );
+extern void fast_set_event( struct fast_sync *obj );
+extern void fast_reset_event( struct fast_sync *obj );
+
 extern struct fast_sync *no_get_fast_sync( struct object *obj );
 
 /* serial functions */
diff --git a/server/protocol.def b/server/protocol.def
index 55c6ef3967f..5e76543f95f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3712,7 +3712,7 @@ struct handle_info
 
 enum fast_sync_type
 {
-    FAST_SYNC_SEMAPHORE,
+    FAST_SYNC_SEMAPHORE = 1,
     FAST_SYNC_MUTEX,
     FAST_SYNC_EVENT,
     FAST_SYNC_SERVER,
-- 
2.11.4.GIT

From 36a789fb9e447a0252a79dbc23c1fab626c4a14e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 11 Mar 2021 16:39:36 -0600
Subject: [PATCH] autoreconf

---
 configure           | 1 +
 include/config.h.in | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/configure b/configure
index a2277f9720d..cf82fce13a8 100755
--- a/configure
+++ b/configure
@@ -7471,6 +7471,7 @@ for ac_header in \
 	linux/serial.h \
 	linux/types.h \
 	linux/ucdrom.h \
+	linux/winesync.h \
 	lwp.h \
 	mach-o/loader.h \
 	mach/mach.h \
diff --git a/include/config.h.in b/include/config.h.in
index 8b2441a548b..8ea51664fe3 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -462,6 +462,9 @@
 /* Define to 1 if you have the <linux/videodev2.h> header file. */
 #undef HAVE_LINUX_VIDEODEV2_H
 
+/* Define to 1 if you have the <linux/winesync.h> header file. */
+#undef HAVE_LINUX_WINESYNC_H
+
 /* Define to 1 if you have the `llrint' function. */
 #undef HAVE_LLRINT
 
-- 
2.11.4.GIT

From e39288bd8fabe526eaa9a46119009cdc67ca949b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 11 Mar 2021 16:45:30 -0600
Subject: [PATCH] server: Create fast synchronization objects for semaphores.

---
 server/fast_sync.c | 34 ++++++++++++++++++++++++++++++++++
 server/object.h    |  1 +
 server/semaphore.c | 25 +++++++++++++++++++++++--
 3 files changed, 58 insertions(+), 2 deletions(-)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 4635e0b3751..090185eb2a5 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -235,6 +235,34 @@ struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset,
     return fast_sync;
 }
 
+struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
+{
+    struct winesync_sem_args args = {0};
+    struct fast_sync_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_fast_sync_device())) return NULL;
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    fast_sync->device = device;
+    fast_sync->type = FAST_SYNC_SEMAPHORE;
+    fast_sync->linux_obj = -1;
+
+    args.count = count;
+    args.max = max;
+    args.flags = WINESYNC_SEM_GETONWAIT;
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_SEM, &args ) < 0)
+    {
+        file_set_error();
+        release_object( fast_sync );
+        return NULL;
+    }
+    fast_sync->linux_obj = args.sem;
+
+    return fast_sync;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
     struct winesync_sem_args args = {0};
@@ -265,6 +293,12 @@ struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset,
     return NULL;
 }
 
+struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
 }
diff --git a/server/object.h b/server/object.h
index f98e4a73a08..58806c4dbeb 100644
--- a/server/object.h
+++ b/server/object.h
@@ -228,6 +228,7 @@ extern void abandon_mutexes( struct thread *thread );
 /* fast-synchronization functions */
 
 extern struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled );
+extern struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max );
 extern void fast_set_event( struct fast_sync *obj );
 extern void fast_reset_event( struct fast_sync *obj );
 
diff --git a/server/semaphore.c b/server/semaphore.c
index 2295f2f4556..6b7e737c848 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -55,12 +55,15 @@ struct semaphore
     struct object  obj;    /* object header */
     unsigned int   count;  /* current count */
     unsigned int   max;    /* maximum possible count */
+    struct fast_sync *fast_sync; /* fast synchronization object */
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int semaphore_signal( struct object *obj, unsigned int access );
+static struct fast_sync *semaphore_get_fast_sync( struct object *obj );
+static void semaphore_destroy( struct object *obj );
 
 static const struct object_ops semaphore_ops =
 {
@@ -82,9 +85,9 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    semaphore_get_fast_sync,       /* get_fast_sync */
     no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
+    semaphore_destroy              /* destroy */
 };
 
 
@@ -106,6 +109,7 @@ static struct semaphore *create_semaphore( struct object *root, const struct uni
             /* initialize it if it didn't already exist */
             sem->count = initial;
             sem->max   = max;
+            sem->fast_sync = NULL;
         }
     }
     return sem;
@@ -168,6 +172,23 @@ static int semaphore_signal( struct object *obj, unsigned int access )
     return release_semaphore( sem, 1, NULL );
 }
 
+static struct fast_sync *semaphore_get_fast_sync( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (!semaphore->fast_sync)
+        semaphore->fast_sync = fast_create_semaphore( semaphore->count, semaphore->max );
+    if (semaphore->fast_sync) grab_object( semaphore->fast_sync );
+    return semaphore->fast_sync;
+}
+
+static void semaphore_destroy( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (semaphore->fast_sync) release_object( semaphore->fast_sync );
+}
+
 /* create a semaphore */
 DECL_HANDLER(create_semaphore)
 {
-- 
2.11.4.GIT

From e3c45d120ca29a68c48eac666fcec4c973027cac Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 11 Mar 2021 16:52:55 -0600
Subject: [PATCH] server: Create fast synchronization objects for mutexes.

---
 server/fast_sync.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++++
 server/mutex.c     | 24 ++++++++++++++++++++----
 server/object.h    |  2 ++
 server/thread.c    |  1 +
 4 files changed, 74 insertions(+), 4 deletions(-)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 090185eb2a5..f68e1acfdc8 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -263,6 +263,33 @@ struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
     return fast_sync;
 }
 
+struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int count )
+{
+    struct winesync_mutex_args args = {0};
+    struct fast_sync_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_fast_sync_device())) return NULL;
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    fast_sync->device = device;
+    fast_sync->type = FAST_SYNC_MUTEX;
+    fast_sync->linux_obj = -1;
+
+    args.owner = owner;
+    args.count = count;
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_MUTEX, &args ) < 0)
+    {
+        file_set_error();
+        release_object( fast_sync );
+        return NULL;
+    }
+    fast_sync->linux_obj = args.mutex;
+
+    return fast_sync;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
     struct winesync_sem_args args = {0};
@@ -285,6 +312,20 @@ void fast_reset_event( struct fast_sync *fast_sync )
     ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_GET_SEM, &fast_sync->linux_obj );
 }
 
+void fast_abandon_mutexes( thread_id_t tid )
+{
+    struct fast_sync_device *device;
+
+    if (!(device = get_fast_sync_device()))
+    {
+        clear_error();
+        return;
+    }
+
+    ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_KILL_OWNER, &tid );
+    release_object( device );
+}
+
 #else
 
 struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled )
@@ -299,6 +340,12 @@ struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
     return NULL;
 }
 
+struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int count )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
 }
@@ -307,4 +354,8 @@ void fast_reset_event( struct fast_sync *obj )
 {
 }
 
+void fast_abandon_mutexes( thread_id_t tid )
+{
+}
+
 #endif
diff --git a/server/mutex.c b/server/mutex.c
index 8d3926e217f..ca5d38da5ea 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -57,6 +57,7 @@ struct mutex
     unsigned int   count;           /* recursion count */
     int            abandoned;       /* has it been abandoned? */
     struct list    entry;           /* entry in owner thread mutex list */
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void mutex_dump( struct object *obj, int verbose );
@@ -64,6 +65,7 @@ static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_destroy( struct object *obj );
 static int mutex_signal( struct object *obj, unsigned int access );
+static struct fast_sync *mutex_get_fast_sync( struct object *obj );
 
 static const struct object_ops mutex_ops =
 {
@@ -85,7 +87,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    mutex_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
@@ -128,6 +130,7 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
             mutex->owner = NULL;
             mutex->abandoned = 0;
             if (owned) do_grab( mutex, current );
+            mutex->fast_sync = NULL;
         }
     }
     return mutex;
@@ -190,14 +193,27 @@ static int mutex_signal( struct object *obj, unsigned int access )
     return 1;
 }
 
+static struct fast_sync *mutex_get_fast_sync( struct object *obj )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+
+    if (!mutex->fast_sync)
+        mutex->fast_sync = fast_create_mutex( mutex->owner ? mutex->owner->id : 0, mutex->count );
+    if (mutex->fast_sync) grab_object( mutex->fast_sync );
+    return mutex->fast_sync;
+}
+
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    if (!mutex->count) return;
-    mutex->count = 0;
-    do_release( mutex );
+    if (mutex->count)
+    {
+        mutex->count = 0;
+        do_release( mutex );
+    }
+    if (mutex->fast_sync) release_object( mutex->fast_sync );
 }
 
 /* create a mutex */
diff --git a/server/object.h b/server/object.h
index 58806c4dbeb..48f7f2d7798 100644
--- a/server/object.h
+++ b/server/object.h
@@ -229,8 +229,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 extern struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled );
 extern struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max );
+extern struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int count );
 extern void fast_set_event( struct fast_sync *obj );
 extern void fast_reset_event( struct fast_sync *obj );
+extern void fast_abandon_mutexes( thread_id_t tid );
 
 extern struct fast_sync *no_get_fast_sync( struct object *obj );
 
diff --git a/server/thread.c b/server/thread.c
index 0e8c711aa05..43f0f1352df 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1277,6 +1277,7 @@ void kill_thread( struct thread *thread, int violent_death )
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
+    fast_abandon_mutexes( thread->id );
     wake_up( &thread->obj, 0 );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
-- 
2.11.4.GIT

From 3c250bb3c01539d12eda651d7c18f16c03b13544 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 11 Mar 2021 20:32:58 -0600
Subject: [PATCH] server: Create fast synchronization objects for completion
 ports.

---
 server/completion.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/server/completion.c b/server/completion.c
index b7eaa5a29bb..776095b3900 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -62,10 +62,12 @@ struct completion
     struct object  obj;
     struct list    queue;
     unsigned int   depth;
+    struct fast_sync *fast_sync;
 };
 
 static void completion_dump( struct object*, int );
 static int completion_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *completion_get_fast_sync( struct object *obj );
 static void completion_destroy( struct object * );
 
 static const struct object_ops completion_ops =
@@ -88,7 +90,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    completion_get_fast_sync,  /* get_fast_sync */
     no_close_handle,           /* close_handle */
     completion_destroy         /* destroy */
 };
@@ -111,6 +113,7 @@ static void completion_destroy( struct object *obj)
     {
         free( tmp );
     }
+    if (completion->fast_sync) release_object( completion->fast_sync );
 }
 
 static void completion_dump( struct object *obj, int verbose )
@@ -128,6 +131,16 @@ static int completion_signaled( struct object *obj, struct wait_queue_entry *ent
     return !list_empty( &completion->queue );
 }
 
+static struct fast_sync *completion_get_fast_sync( struct object *obj )
+{
+    struct completion *completion = (struct completion *)obj;
+
+    if (!completion->fast_sync)
+        completion->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, !list_empty( &completion->queue ) );
+    if (completion->fast_sync) grab_object( completion->fast_sync );
+    return completion->fast_sync;
+}
+
 static struct completion *create_completion( struct object *root, const struct unicode_str *name,
                                              unsigned int attr, unsigned int concurrent,
                                              const struct security_descriptor *sd )
@@ -140,6 +153,7 @@ static struct completion *create_completion( struct object *root, const struct u
         {
             list_init( &completion->queue );
             completion->depth = 0;
+            completion->fast_sync = NULL;
         }
     }
 
@@ -167,6 +181,7 @@ void add_completion( struct completion *completion, apc_param_t ckey, apc_param_
     list_add_tail( &completion->queue, &msg->queue_entry );
     completion->depth++;
     wake_up( &completion->obj, 1 );
+    fast_set_event( completion->fast_sync );
 }
 
 /* create a completion */
@@ -233,6 +248,8 @@ DECL_HANDLER(remove_completion)
         reply->status = msg->status;
         reply->information = msg->information;
         free( msg );
+        if (list_empty( &completion->queue ))
+            fast_reset_event( completion->fast_sync );
     }
 
     release_object( completion );
-- 
2.11.4.GIT

From 9e5baa5500d52165bd6e8158d2d3af0c2e0fc5ff Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 16:54:34 -0600
Subject: [PATCH] server: Create fast synchronization objects for consoles.

---
 server/console.c | 64 +++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 59 insertions(+), 5 deletions(-)

diff --git a/server/console.c b/server/console.c
index d1d47a7e4bf..5f56e50262a 100644
--- a/server/console.c
+++ b/server/console.c
@@ -62,6 +62,7 @@ struct console
     struct fd                   *fd;            /* for bare console, attached input fd */
     struct async_queue           ioctl_q;       /* ioctl queue */
     struct async_queue           read_q;        /* read queue */
+    struct fast_sync            *fast_sync;     /* fast synchronization object */
 };
 
 static void console_dump( struct object *obj, int verbose );
@@ -72,6 +73,7 @@ static struct object *console_lookup_name( struct object *obj, struct unicode_st
                                            unsigned int attr, struct object *root );
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
+static struct fast_sync *console_get_fast_sync( struct object *obj );
 
 static const struct object_ops console_ops =
 {
@@ -93,7 +95,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_get_fast_sync,            /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -217,6 +219,7 @@ static int screen_buffer_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *screen_buffer_get_fd( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static struct fast_sync *screen_buffer_get_fast_sync( struct object *obj );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -238,7 +241,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    screen_buffer_get_fast_sync,      /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -303,6 +306,7 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
                                                unsigned int sharing, unsigned int options );
 static int console_input_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_input_get_fd( struct object *obj );
+static struct fast_sync *console_input_get_fast_sync( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
 static const struct object_ops console_input_ops =
@@ -325,7 +329,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_input_get_fast_sync,      /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -360,6 +364,7 @@ static int console_output_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *console_output_get_fd( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct fast_sync *console_output_get_fast_sync( struct object *obj );
 static void console_output_destroy( struct object *obj );
 
 static const struct object_ops console_output_ops =
@@ -382,7 +387,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_output_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -523,6 +528,7 @@ static struct object *create_console(void)
     console->server        = NULL;
     console->fd            = NULL;
     console->last_id       = 0;
+    console->fast_sync     = NULL;
     init_async_queue( &console->ioctl_q );
     init_async_queue( &console->read_q );
 
@@ -725,6 +731,8 @@ static void console_destroy( struct object *obj )
     free_async_queue( &console->read_q );
     if (console->fd)
         release_object( console->fd );
+
+    if (console->fast_sync) release_object( console->fast_sync );
 }
 
 static struct object *create_console_connection( struct console *console )
@@ -772,6 +780,16 @@ static struct object *console_open_file( struct object *obj, unsigned int access
     return grab_object( obj );
 }
 
+static struct fast_sync *console_get_fast_sync( struct object *obj )
+{
+    struct console *console = (struct console *)obj;
+
+    if (!console->fast_sync)
+        console->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, console->signaled );
+    if (console->fast_sync) grab_object( console->fast_sync );
+    return console->fast_sync;
+}
+
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -821,6 +839,17 @@ static struct fd *screen_buffer_get_fd( struct object *obj )
     return NULL;
 }
 
+static struct fast_sync *screen_buffer_get_fast_sync( struct object *obj )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+    if (!screen_buffer->input)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &screen_buffer->input->obj );
+}
+
 static void console_server_dump( struct object *obj, int verbose )
 {
     assert( obj->ops == &console_server_ops );
@@ -1346,6 +1375,16 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_input_get_fast_sync( struct object *obj )
+{
+    if (!current->process->console)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &current->process->console->obj );
+}
+
 static void console_input_destroy( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
@@ -1418,6 +1457,16 @@ static struct object *console_output_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_output_get_fast_sync( struct object *obj )
+{
+    if (!current->process->console || !current->process->console->active)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &current->process->console->obj );
+}
+
 static void console_output_destroy( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
@@ -1475,11 +1524,16 @@ DECL_HANDLER(get_next_console_request)
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) server->console->signaled = 0;
+    if (!req->signal)
+    {
+        server->console->signaled = 0;
+        fast_reset_event( server->console->fast_sync );
+    }
     else if (!server->console->signaled)
     {
         server->console->signaled = 1;
         wake_up( &server->console->obj, 0 );
+        fast_set_event( server->console->fast_sync );
     }
 
     if (req->read)
-- 
2.11.4.GIT

From f0ce53eb7cb46f4c9752447ca333f57836ee5610 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:00:51 -0600
Subject: [PATCH] server: Create fast synchronization objects for console
 servers.

---
 server/console.c | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/server/console.c b/server/console.c
index 5f56e50262a..a6d192394eb 100644
--- a/server/console.c
+++ b/server/console.c
@@ -140,6 +140,7 @@ struct console_server
     int                   busy;        /* flag if server processing an ioctl */
     int                   term_fd;     /* UNIX terminal fd */
     struct termios        termios;     /* original termios */
+    struct fast_sync     *fast_sync;   /* fast synchronization object */
 };
 
 static void console_server_dump( struct object *obj, int verbose );
@@ -150,6 +151,7 @@ static struct object *console_server_lookup_name( struct object *obj, struct uni
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct fast_sync *console_server_get_fast_sync( struct object *obj );
 
 static const struct object_ops console_server_ops =
 {
@@ -171,7 +173,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_server_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -568,6 +570,7 @@ static int queue_host_ioctl( struct console_server *server, unsigned int code, u
     }
     list_add_tail( &server->queue, &ioctl->entry );
     wake_up( &server->obj, 0 );
+    fast_set_event( server->fast_sync );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -600,6 +603,7 @@ static void disconnect_console_server( struct console_server *server )
         server->console->server = NULL;
         server->console = NULL;
         wake_up( &server->obj, 0 );
+        fast_set_event( server->fast_sync );
     }
 }
 
@@ -862,6 +866,7 @@ static void console_server_destroy( struct object *obj )
     assert( obj->ops == &console_server_ops );
     disconnect_console_server( server );
     if (server->fd) release_object( server->fd );
+    if (server->fast_sync) release_object( server->fast_sync );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -916,6 +921,17 @@ static struct object *console_server_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_server_get_fast_sync( struct object *obj )
+{
+    struct console_server *server = (struct console_server *)obj;
+    int signaled = !server->console || !list_empty( &server->queue );
+
+    if (!server->fast_sync)
+        server->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, signaled );
+    if (server->fast_sync) grab_object( server->fast_sync );
+    return server->fast_sync;
+}
+
 static struct object *create_console_server( void )
 {
     struct console_server *server;
@@ -926,6 +942,7 @@ static struct object *create_console_server( void )
     server->term_fd = -1;
     list_init( &server->queue );
     list_init( &server->read_queue );
+    server->fast_sync = NULL;
     server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
     if (!server->fd)
     {
@@ -1555,6 +1572,8 @@ DECL_HANDLER(get_next_console_request)
         /* set result of previous ioctl */
         ioctl = LIST_ENTRY( list_head( &server->queue ), struct console_host_ioctl, entry );
         list_remove( &ioctl->entry );
+        if (list_empty( &server->queue ))
+            fast_reset_event( server->fast_sync );
     }
 
     if (ioctl)
@@ -1654,5 +1673,8 @@ DECL_HANDLER(get_next_console_request)
         set_error( STATUS_PENDING );
     }
 
+    if (list_empty( &server->queue ))
+        fast_reset_event( server->fast_sync );
+
     release_object( server );
 }
-- 
2.11.4.GIT

From d960e2ee6c42ed9ce4ab4b5a1b3f61b08ded84cf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:11:03 -0600
Subject: [PATCH] server: Create fast synchronization objects for debug
 objects.

---
 server/debugger.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/server/debugger.c b/server/debugger.c
index f891af48723..4967adcdc73 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -72,6 +72,7 @@ struct debug_obj
     struct object        obj;         /* object header */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
+    struct fast_sync    *fast_sync;   /* fast synchronization object */
 };
 
 
@@ -106,6 +107,7 @@ static const struct object_ops debug_event_ops =
 
 static void debug_obj_dump( struct object *obj, int verbose );
 static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *debug_obj_get_fast_sync( struct object *obj );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -128,7 +130,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    debug_obj_get_fast_sync,       /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
@@ -256,6 +258,7 @@ static void link_event( struct debug_obj *debug_obj, struct debug_event *event )
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        fast_set_event( debug_obj->fast_sync );
         release_object( debug_obj );
     }
 }
@@ -268,6 +271,7 @@ static void resume_event( struct debug_obj *debug_obj, struct debug_event *event
     {
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        fast_set_event( debug_obj->fast_sync );
         release_object( debug_obj );
     }
 }
@@ -333,6 +337,17 @@ static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entr
     return find_event_to_send( debug_obj ) != NULL;
 }
 
+static struct fast_sync *debug_obj_get_fast_sync( struct object *obj )
+{
+    struct debug_obj *debug_obj = (struct debug_obj *)obj;
+    int signaled = find_event_to_send( debug_obj ) != NULL;
+
+    if (!debug_obj->fast_sync)
+        debug_obj->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, signaled );
+    if (debug_obj->fast_sync) grab_object( debug_obj->fast_sync );
+    return debug_obj->fast_sync;
+}
+
 static void debug_obj_destroy( struct object *obj )
 {
     struct list *ptr;
@@ -345,6 +360,8 @@ static void debug_obj_destroy( struct object *obj )
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
+
+    if (debug_obj->fast_sync) release_object( debug_obj->fast_sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -364,6 +381,7 @@ static struct debug_obj *create_debug_obj( struct object *root, const struct uni
         {
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
+            debug_obj->fast_sync = NULL;
         }
     }
     return debug_obj;
@@ -572,6 +590,9 @@ DECL_HANDLER(wait_debug_event)
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
+
+        if (!find_event_to_send( debug_obj ))
+            fast_reset_event( debug_obj->fast_sync );
     }
     else
     {
-- 
2.11.4.GIT

From d38e20a367e455bcb9ea5899653deb52b0c32300 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 11:02:42 -0600
Subject: [PATCH] server: Create fast synchronization objects for device
 managers.

---
 server/device.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/server/device.c b/server/device.c
index 8e5cad82b97..8dcd000acae 100644
--- a/server/device.c
+++ b/server/device.c
@@ -95,10 +95,12 @@ struct device_manager
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
+    struct fast_sync      *fast_sync;      /* fast synchronization object */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *device_manager_get_fast_sync( struct object *obj );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -121,7 +123,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    device_manager_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -443,7 +445,12 @@ static void add_irp_to_queue( struct device_manager *manager, struct irp_call *i
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
+    if (list_head( &manager->requests ) == &irp->mgr_entry)
+    {
+        /* first one */
+        wake_up( &manager->obj, 0 );
+        fast_set_event( manager->fast_sync );
+    }
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -779,6 +786,9 @@ static void delete_file( struct device_file *file )
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
+    if (list_empty( &file->device->manager->requests ))
+        fast_reset_event( file->device->manager->fast_sync );
+
     release_object( file );
 }
 
@@ -810,6 +820,16 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
     return !list_empty( &manager->requests );
 }
 
+static struct fast_sync *device_manager_get_fast_sync( struct object *obj )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+
+    if (!manager->fast_sync)
+        manager->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, !list_empty( &manager->requests ) );
+    if (manager->fast_sync) grab_object( manager->fast_sync );
+    return manager->fast_sync;
+}
+
 static void device_manager_destroy( struct object *obj )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -844,6 +864,8 @@ static void device_manager_destroy( struct object *obj )
         assert( !irp->file && !irp->async );
         release_object( irp );
     }
+
+    if (manager->fast_sync) release_object( manager->fast_sync );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -853,6 +875,7 @@ static struct device_manager *create_device_manager(void)
     if ((manager = alloc_object( &device_manager_ops )))
     {
         manager->current_call = NULL;
+        manager->fast_sync = NULL;
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
@@ -1018,6 +1041,10 @@ DECL_HANDLER(get_next_device_request)
                 iosb->in_size = 0;
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
+
+                if (list_empty( &manager->requests ))
+                    fast_reset_event( manager->fast_sync );
+
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
-- 
2.11.4.GIT

From a54a174ea0f54c76ab077c3d402e8034822d1c05 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:13:20 -0600
Subject: [PATCH] server: Create fast synchronization objects for keyed events.

---
 server/event.c | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/server/event.c b/server/event.c
index dfaec131f09..857bc1ab23b 100644
--- a/server/event.c
+++ b/server/event.c
@@ -110,10 +110,13 @@ struct type_descr keyed_event_type =
 struct keyed_event
 {
     struct object  obj;             /* object header */
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void keyed_event_dump( struct object *obj, int verbose );
 static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *keyed_event_get_fast_sync( struct object *obj );
+static void keyed_event_destroy( struct object *obj );
 
 static const struct object_ops keyed_event_ops =
 {
@@ -135,9 +138,9 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
-    no_get_fast_sync,            /* get_fast_sync */
+    keyed_event_get_fast_sync,   /* get_fast_sync */
     no_close_handle,             /* close_handle */
-    no_destroy                   /* destroy */
+    keyed_event_destroy          /* destroy */
 };
 
 
@@ -258,6 +261,7 @@ struct keyed_event *create_keyed_event( struct object *root, const struct unicod
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
+            event->fast_sync = NULL;
         }
     }
     return event;
@@ -301,6 +305,23 @@ static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *en
     return 0;
 }
 
+static struct fast_sync *keyed_event_get_fast_sync( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (!event->fast_sync)
+        event->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, 1 );
+    if (event->fast_sync) grab_object( event->fast_sync );
+    return event->fast_sync;
+}
+
+static void keyed_event_destroy( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (event->fast_sync) release_object( event->fast_sync );
+}
+
 /* create an event */
 DECL_HANDLER(create_event)
 {
-- 
2.11.4.GIT

From 7f3f4a8e0fe07f5d1097c69b12fe79b50b212ef0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:16:53 -0600
Subject: [PATCH] server: Create fast synchronization objects for processes.

---
 server/process.c | 17 ++++++++++++++++-
 server/process.h |  1 +
 2 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index 6a869e4f7e7..3dfc3175a66 100644
--- a/server/process.c
+++ b/server/process.c
@@ -80,6 +80,7 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *process_get_fast_sync( struct object *obj );
 static void process_destroy( struct object *obj );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
@@ -103,7 +104,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,            /* get_fast_sync */
+    process_get_fast_sync,       /* get_fast_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -555,6 +556,7 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
     process->trace_data      = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->fast_sync       = NULL;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -655,6 +657,8 @@ static void process_destroy( struct object *obj )
     if (process->token) release_object( process->token );
     free( process->dir_cache );
     free( process->image );
+
+    if (process->fast_sync) release_object( process->fast_sync );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -686,6 +690,16 @@ static struct list *process_get_kernel_obj_list( struct object *obj )
     return &process->kernel_object;
 }
 
+static struct fast_sync *process_get_fast_sync( struct object *obj )
+{
+    struct process *process = (struct process *)obj;
+
+    if (!process->fast_sync)
+        process->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, !process->running_threads );
+    if (process->fast_sync) grab_object( process->fast_sync );
+    return process->fast_sync;
+}
+
 static struct security_descriptor *process_get_sd( struct object *obj )
 {
     static struct security_descriptor *process_default_sd;
@@ -866,6 +880,7 @@ static void process_killed( struct process *process )
     release_job_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
+    fast_set_event( process->fast_sync );
 }
 
 /* add a thread to a process running threads list */
diff --git a/server/process.h b/server/process.h
index 0997a759330..339c0cb1658 100644
--- a/server/process.h
+++ b/server/process.h
@@ -87,6 +87,7 @@ struct process
     const struct rawinput_device *rawinput_mouse; /* rawinput mouse device, if any */
     const struct rawinput_device *rawinput_kbd;   /* rawinput keyboard device, if any */
     struct list          kernel_object;   /* list of kernel object pointers */
+    struct fast_sync    *fast_sync;       /* fast synchronization object */
 };
 
 #define CPU_FLAG(cpu) (1 << (cpu))
-- 
2.11.4.GIT

From 517ecf73ba1a4d5eacf5587a47d2ca5471ed09cd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:17:35 -0600
Subject: [PATCH] server: Create fast synchronization objects for jobs.

---
 server/process.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index 3dfc3175a66..ba58a0931a6 100644
--- a/server/process.c
+++ b/server/process.c
@@ -179,6 +179,7 @@ struct type_descr job_type =
 
 static void job_dump( struct object *obj, int verbose );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *job_get_fast_sync( struct object *obj );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
@@ -193,6 +194,7 @@ struct job
     int signaled;                  /* job is signaled */
     struct completion *completion_port; /* associated completion port */
     apc_param_t completion_key;    /* key to send with completion messages */
+    struct fast_sync *fast_sync;   /* fast synchronization object */
 };
 
 static const struct object_ops job_ops =
@@ -215,7 +217,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    job_get_fast_sync,             /* get_fast_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
@@ -238,6 +240,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             job->signaled = 0;
             job->completion_port = NULL;
             job->completion_key = 0;
+            job->fast_sync = NULL;
         }
     }
     return job;
@@ -303,6 +306,17 @@ static void terminate_job( struct job *job, int exit_code )
     job->terminating = 0;
     job->signaled = 1;
     wake_up( &job->obj, 0 );
+    fast_set_event( job->fast_sync );
+}
+
+static struct fast_sync *job_get_fast_sync( struct object *obj )
+{
+    struct job *job = (struct job *)obj;
+
+    if (!job->fast_sync)
+        job->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, job->signaled );
+    if (job->fast_sync) grab_object( job->fast_sync );
+    return job->fast_sync;
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -327,6 +341,8 @@ static void job_destroy( struct object *obj )
     assert( list_empty(&job->process_list) );
 
     if (job->completion_port) release_object( job->completion_port );
+
+    if (job->fast_sync) release_object( job->fast_sync );
 }
 
 static void job_dump( struct object *obj, int verbose )
-- 
2.11.4.GIT

From 88b2907ccabaf55312edd98c3d73a21d7c61cac8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:24:15 -0600
Subject: [PATCH] server: Create fast synchronization objects for message
 queues.

---
 server/queue.c | 48 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 44 insertions(+), 4 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 9444b6ba7f5..ca2c62fee10 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -140,6 +140,7 @@ struct msg_queue
     struct thread_input   *input;           /* thread input descriptor */
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
+    struct fast_sync      *fast_sync;       /* fast synchronization object */
 };
 
 struct hotkey
@@ -157,6 +158,7 @@ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *ent
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *msg_queue_get_fast_sync( struct object *obj );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -183,7 +185,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    msg_queue_get_fast_sync,   /* get_fast_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -307,6 +309,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->input           = (struct thread_input *)grab_object( input );
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
+        queue->fast_sync       = NULL;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -481,7 +484,11 @@ static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
 {
     queue->wake_bits |= bits;
     queue->changed_bits |= bits;
-    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
+    if (is_signaled( queue ))
+    {
+        wake_up( &queue->obj, 0 );
+        fast_set_event( queue->fast_sync );
+    }
 }
 
 /* clear some queue bits */
@@ -489,6 +496,8 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
 {
     queue->wake_bits &= ~bits;
     queue->changed_bits &= ~bits;
+    if (!is_signaled( queue ))
+        fast_reset_event( queue->fast_sync );
 }
 
 /* check whether msg is a keyboard message */
@@ -998,6 +1007,17 @@ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *en
     struct msg_queue *queue = (struct msg_queue *)obj;
     queue->wake_mask = 0;
     queue->changed_mask = 0;
+    fast_reset_event( queue->fast_sync );
+}
+
+static struct fast_sync *msg_queue_get_fast_sync( struct object *obj )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    if (!queue->fast_sync)
+        queue->fast_sync = fast_create_event( FAST_SYNC_QUEUE, 1, is_signaled( queue ) );
+    if (queue->fast_sync) grab_object( queue->fast_sync );
+    return queue->fast_sync;
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -1036,6 +1056,7 @@ static void msg_queue_destroy( struct object *obj )
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
+    if (queue->fast_sync) release_object( queue->fast_sync );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1046,6 +1067,7 @@ static void msg_queue_poll_event( struct fd *fd, int event )
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
     wake_up( &queue->obj, 0 );
+    fast_set_event( queue->fast_sync );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -2352,8 +2374,20 @@ DECL_HANDLER(set_queue_mask)
         if (is_signaled( queue ))
         {
             /* if skip wait is set, do what would have been done in the subsequent wait */
-            if (req->skip_wait) queue->wake_mask = queue->changed_mask = 0;
-            else wake_up( &queue->obj, 0 );
+            if (req->skip_wait)
+            {
+                queue->wake_mask = queue->changed_mask = 0;
+                fast_reset_event( queue->fast_sync );
+            }
+            else
+            {
+                wake_up( &queue->obj, 0 );
+                fast_set_event( queue->fast_sync );
+            }
+        }
+        else
+        {
+            fast_reset_event( queue->fast_sync );
         }
     }
 }
@@ -2368,6 +2402,8 @@ DECL_HANDLER(get_queue_status)
         reply->wake_bits    = queue->wake_bits;
         reply->changed_bits = queue->changed_bits;
         queue->changed_bits &= ~req->clear_bits;
+        if (!is_signaled( queue ))
+            fast_reset_event( queue->fast_sync );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
@@ -2551,6 +2587,9 @@ DECL_HANDLER(get_message)
     if (filter & QS_INPUT) queue->changed_bits &= ~QS_INPUT;
     if (filter & QS_PAINT) queue->changed_bits &= ~QS_PAINT;
 
+    if (!is_signaled( queue ))
+        fast_reset_event( queue->fast_sync );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -2604,6 +2643,7 @@ DECL_HANDLER(get_message)
     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
+    fast_reset_event( queue->fast_sync );
     set_error( STATUS_PENDING );  /* FIXME */
 }
 
-- 
2.11.4.GIT

From 21eb547f062d1a430ea51aa75c94f68ff22ecea6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:26:35 -0600
Subject: [PATCH] server: Create fast synchronization objects for threads.

---
 server/thread.c | 16 +++++++++++++++-
 server/thread.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 43f0f1352df..3b6dedb613f 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -188,6 +188,7 @@ static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *thread_get_fast_sync( struct object *obj );
 static void destroy_thread( struct object *obj );
 
 static const struct object_ops thread_ops =
@@ -210,7 +211,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,           /* get_fast_sync */
+    thread_get_fast_sync,       /* get_fast_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
@@ -258,6 +259,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->token           = NULL;
     thread->desc            = NULL;
     thread->desc_len        = 0;
+    thread->fast_sync       = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -396,6 +398,16 @@ static struct list *thread_get_kernel_obj_list( struct object *obj )
     return &thread->kernel_object;
 }
 
+static struct fast_sync *thread_get_fast_sync( struct object *obj )
+{
+    struct thread *thread = (struct thread *)obj;
+
+    if (!thread->fast_sync)
+        thread->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, thread->state == TERMINATED );
+    if (thread->fast_sync) grab_object( thread->fast_sync );
+    return thread->fast_sync;
+}
+
 /* cleanup everything that is no longer needed by a dead thread */
 /* used by destroy_thread and kill_thread */
 static void cleanup_thread( struct thread *thread )
@@ -450,6 +462,7 @@ static void destroy_thread( struct object *obj )
     release_object( thread->process );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
+    if (thread->fast_sync) release_object( thread->fast_sync );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1279,6 +1292,7 @@ void kill_thread( struct thread *thread, int violent_death )
     abandon_mutexes( thread );
     fast_abandon_mutexes( thread->id );
     wake_up( &thread->obj, 0 );
+    fast_set_event( thread->fast_sync );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
diff --git a/server/thread.h b/server/thread.h
index 5f8eeeb3c50..071f727dd1d 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -90,6 +90,7 @@ struct thread
     struct list            kernel_object; /* list of kernel object pointers */
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
+    struct fast_sync      *fast_sync;     /* fast synchronization object */
 };
 
 extern struct thread *current;
-- 
2.11.4.GIT

From 7e574f43dc74d5def545dcc2d5d7ba88cc7bb289 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:29:38 -0600
Subject: [PATCH] server: Create fast synchronization objects for timers.

---
 server/timer.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/server/timer.c b/server/timer.c
index c6417fc9a43..8b6dcb3b829 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -62,11 +62,13 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    struct fast_sync    *fast_sync; /* fast synchronization object */
 };
 
 static void timer_dump( struct object *obj, int verbose );
 static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *timer_get_fast_sync( struct object *obj );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -89,7 +91,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    timer_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
@@ -112,6 +114,7 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+            timer->fast_sync = NULL;
         }
     }
     return timer;
@@ -155,6 +158,7 @@ static void timer_callback( void *private )
     /* wake up waiters */
     timer->signaled = 1;
     wake_up( &timer->obj, 0 );
+    fast_set_event( timer->fast_sync );
 }
 
 /* cancel a running timer */
@@ -185,6 +189,7 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
     {
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
+        fast_reset_event( timer->fast_sync );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -219,6 +224,16 @@ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry
     if (!timer->manual) timer->signaled = 0;
 }
 
+static struct fast_sync *timer_get_fast_sync( struct object *obj )
+{
+    struct timer *timer = (struct timer *)obj;
+
+    if (!timer->fast_sync)
+        timer->fast_sync = fast_create_event( FAST_SYNC_SERVER, timer->manual, timer->signaled );
+    if (timer->fast_sync) grab_object( timer->fast_sync );
+    return timer->fast_sync;
+}
+
 static void timer_destroy( struct object *obj )
 {
     struct timer *timer = (struct timer *)obj;
@@ -226,6 +241,7 @@ static void timer_destroy( struct object *obj )
 
     if (timer->timeout) remove_timeout_user( timer->timeout );
     if (timer->thread) release_object( timer->thread );
+    if (timer->fast_sync) release_object( timer->fast_sync );
 }
 
 /* create a timer */
-- 
2.11.4.GIT

From a2e7fcdd4d07661780f504979fe08c7f412cab93 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:40:57 -0600
Subject: [PATCH] server: Create fast synchronization objects for fd-based
 objects.

---
 server/change.c     |  2 +-
 server/device.c     |  2 +-
 server/fd.c         | 27 ++++++++++++++++++++++++++-
 server/file.c       |  2 +-
 server/file.h       |  1 +
 server/mailslot.c   |  4 ++--
 server/named_pipe.c |  6 +++---
 server/serial.c     |  2 +-
 server/sock.c       |  2 +-
 9 files changed, 37 insertions(+), 11 deletions(-)

diff --git a/server/change.c b/server/change.c
index 55c848bfe28..0eadae4e96d 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,7 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
-    no_get_fast_sync,         /* get_fast_sync */
+    default_fd_get_fast_sync, /* get_fast_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 8dcd000acae..b3f4329d11b 100644
--- a/server/device.c
+++ b/server/device.c
@@ -234,7 +234,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    default_fd_get_fast_sync,         /* get_fast_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 3361b3b4bbe..6ef4e563a6e 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -199,6 +199,7 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    struct fast_sync    *fast_sync;   /* fast synchronization object */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -1587,6 +1588,7 @@ static void fd_destroy( struct object *obj )
         if (fd->unix_fd != -1) close( fd->unix_fd );
         free( fd->unix_name );
     }
+    if (fd->fast_sync) release_object( fd->fast_sync );
 }
 
 /* check if the desired access is possible without violating */
@@ -1703,6 +1705,7 @@ static struct fd *alloc_fd_object(void)
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->fast_sync  = NULL;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
@@ -1741,6 +1744,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->fast_sync  = NULL;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
@@ -2119,7 +2123,15 @@ void set_fd_signaled( struct fd *fd, int signaled )
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
-    if (signaled) wake_up( fd->user, 0 );
+    if (signaled)
+    {
+        wake_up( fd->user, 0 );
+        fast_set_event( fd->fast_sync );
+    }
+    else
+    {
+        fast_reset_event( fd->fast_sync );
+    }
 }
 
 /* handler for close_handle that refuses to close fd-associated handles in other processes */
@@ -2151,6 +2163,19 @@ int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
     return ret;
 }
 
+struct fast_sync *default_fd_get_fast_sync( struct object *obj )
+{
+    struct fd *fd = get_obj_fd( obj );
+    struct fast_sync *ret;
+
+    if (!fd->fast_sync)
+        fd->fast_sync = fast_create_event( FAST_SYNC_SERVER, 1, fd->signaled );
+    ret = fd->fast_sync;
+    release_object( fd );
+    if (ret) grab_object( ret );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
diff --git a/server/file.c b/server/file.c
index 39aff28165c..033f7d45976 100644
--- a/server/file.c
+++ b/server/file.c
@@ -109,7 +109,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/file.h b/server/file.h
index 0fa66e5750a..eaabd72b224 100644
--- a/server/file.h
+++ b/server/file.h
@@ -103,6 +103,7 @@ extern char *dup_fd_name( struct fd *root, const char *name );
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern struct fast_sync *default_fd_get_fast_sync( struct object *obj );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
 extern void fd_queue_async( struct fd *fd, struct async *async, int type );
diff --git a/server/mailslot.c b/server/mailslot.c
index 1cb01307326..88aee771e5e 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -90,7 +90,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    default_fd_get_fast_sync,  /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -243,7 +243,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
-    no_get_fast_sync,                       /* get_fast_sync */
+    default_fd_get_fast_sync,               /* get_fast_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 50ead981d0e..3bc91bb8350 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -180,7 +180,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -224,7 +224,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -303,7 +303,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_fast_sync,                        /* get_fast_sync */
+    default_fd_get_fast_sync,                /* get_fast_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 87f6bf56b40..8c68aafe61f 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -104,7 +104,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 48918c14a08..26969059bfe 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -201,7 +201,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
-- 
2.11.4.GIT

From 576083e978719216d34a370e4f2e584a882e1275 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:46:06 -0600
Subject: [PATCH] server: Add a request to retrieve the fast synchronization
 device.

---
 server/fast_sync.c  | 19 +++++++++++++++++++
 server/protocol.def |  7 +++++++
 2 files changed, 26 insertions(+)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index f68e1acfdc8..a751e49f083 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -37,6 +37,8 @@
 #include "winternl.h"
 
 #include "file.h"
+#include "handle.h"
+#include "request.h"
 #include "thread.h"
 
 #ifdef HAVE_LINUX_WINESYNC_H
@@ -328,6 +330,12 @@ void fast_abandon_mutexes( thread_id_t tid )
 
 #else
 
+static struct fast_sync_device *get_fast_sync_device(void)
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 struct fast_sync *fast_create_event( enum fast_sync_type type, int manual_reset, int signaled )
 {
     set_error( STATUS_NOT_IMPLEMENTED );
@@ -359,3 +367,14 @@ void fast_abandon_mutexes( thread_id_t tid )
 }
 
 #endif
+
+DECL_HANDLER(get_fast_sync_device)
+{
+    struct fast_sync_device *device;
+
+    if ((device = get_fast_sync_device()))
+    {
+        reply->handle = alloc_handle( current->process, device, 0, 0 );
+        release_object( device );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index 5e76543f95f..b141abbaf85 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3718,3 +3718,10 @@ enum fast_sync_type
     FAST_SYNC_SERVER,
     FAST_SYNC_QUEUE,
 };
+
+
+/* Obtain a handle to the fast synchronization device object */
+@REQ(get_fast_sync_device)
+@REPLY
+    obj_handle_t handle;          /* handle to the device */
+@END
-- 
2.11.4.GIT

From 64e5a73b91fa466e79e675500042fe924152d6ed Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 17:55:00 -0600
Subject: [PATCH] server: Add a request to retrieve the fast synchronization
 object from a handle.

---
 server/fast_sync.c  | 20 ++++++++++++++++++++
 server/protocol.def | 11 +++++++++++
 2 files changed, 31 insertions(+)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index a751e49f083..f5402078d66 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -378,3 +378,23 @@ DECL_HANDLER(get_fast_sync_device)
         release_object( device );
     }
 }
+
+DECL_HANDLER(get_fast_sync_obj)
+{
+    struct object *obj;
+
+    if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
+    {
+        struct fast_sync *fast_sync;
+
+        if ((fast_sync = obj->ops->get_fast_sync( obj )) >= 0)
+        {
+            reply->handle = alloc_handle( current->process, fast_sync, 0, 0 );
+            reply->obj = fast_sync->linux_obj;
+            reply->type = fast_sync->type;
+            reply->access = get_handle_access( current->process, req->handle );
+            release_object( fast_sync );
+        }
+        release_object( obj );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index b141abbaf85..e6bb977dd61 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3725,3 +3725,14 @@ enum fast_sync_type
 @REPLY
     obj_handle_t handle;          /* handle to the device */
 @END
+
+
+/* Get the fast synchronization object associated with the given handle */
+@REQ(get_fast_sync_obj)
+    obj_handle_t handle;          /* handle to the object */
+@REPLY
+    obj_handle_t handle;          /* handle to the fast synchronization object */
+    int          obj;             /* linux object */
+    int          type;            /* object type */
+    unsigned int access;          /* handle access rights */
+@END
-- 
2.11.4.GIT

From 8fcba6202617761182717b0f4662dd17e3507a35 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 9 Mar 2021 11:32:25 -0600
Subject: [PATCH] server: Introduce fast_select_queue and fast_unselect_queue
 requests.

---
 server/protocol.def | 13 ++++++++++++
 server/queue.c      | 59 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 72 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index e6bb977dd61..23b516dc42f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3736,3 +3736,16 @@ enum fast_sync_type
     int          type;            /* object type */
     unsigned int access;          /* handle access rights */
 @END
+
+
+/* Begin a fast wait on a message queue */
+@REQ(fast_select_queue)
+    obj_handle_t handle;          /* handle to the queue */
+@END
+
+
+/* End a fast wait on a message queue */
+@REQ(fast_unselect_queue)
+    obj_handle_t handle;          /* handle to the queue */
+    int          signaled;        /* was the queue signaled? */
+@END
diff --git a/server/queue.c b/server/queue.c
index ca2c62fee10..120b2bf4763 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -141,6 +141,7 @@ struct msg_queue
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
     struct fast_sync      *fast_sync;       /* fast synchronization object */
+    int                    in_fast_wait;    /* are we in a fast wait? */
 };
 
 struct hotkey
@@ -310,6 +311,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->fast_sync       = NULL;
+        queue->in_fast_wait    = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -947,6 +949,10 @@ static int is_queue_hung( struct msg_queue *queue )
         if (get_wait_queue_thread(entry)->queue == queue)
             return 0;  /* thread is waiting on queue -> not hung */
     }
+
+    if (queue->in_fast_wait)
+        return 0;  /* thread is waiting on queue in absentia -> not hung */
+
     return 1;
 }
 
@@ -3381,3 +3387,56 @@ DECL_HANDLER(get_rawinput_devices)
             devices[i++] = e->device;
     }
 }
+
+DECL_HANDLER(fast_select_queue)
+{
+    struct msg_queue *queue;
+
+    if (!(queue = (struct msg_queue *)get_handle_obj( current->process, req->handle,
+                                                      SYNCHRONIZE, &msg_queue_ops )))
+        return;
+
+    /* a thread can only wait on its own queue */
+    if (current->queue != queue || queue->in_fast_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (current->process->idle_event && !(queue->wake_mask & QS_SMRESULT))
+            set_event( current->process->idle_event );
+
+        if (queue->fd)
+            set_fd_events( queue->fd, POLLIN );
+
+        queue->in_fast_wait = 1;
+    }
+
+    release_object( queue );
+}
+
+DECL_HANDLER(fast_unselect_queue)
+{
+    struct msg_queue *queue;
+
+    if (!(queue = (struct msg_queue *)get_handle_obj( current->process, req->handle,
+                                                      SYNCHRONIZE, &msg_queue_ops )))
+        return;
+
+    if (current->queue != queue || !queue->in_fast_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (queue->fd)
+            set_fd_events( queue->fd, 0 );
+
+        if (req->signaled)
+            msg_queue_satisfied( &queue->obj, NULL );
+
+        queue->in_fast_wait = 0;
+    }
+
+    release_object( queue );
+}
-- 
2.11.4.GIT

From 100e0acbf4242f5e8404b3ccdd526d26629a1778 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 9 Mar 2021 10:54:40 -0600
Subject: [PATCH] server: Send a signal for user APCs when using fast
 synchronization.

---
 server/fast_sync.c | 10 ++++++++++
 server/object.h    |  1 +
 server/thread.c    |  5 +++--
 3 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index f5402078d66..834a8d9e6b6 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -328,6 +328,11 @@ void fast_abandon_mutexes( thread_id_t tid )
     release_object( device );
 }
 
+int fast_user_apc_needs_signal(void)
+{
+    return !!fast_sync_device_object;
+}
+
 #else
 
 static struct fast_sync_device *get_fast_sync_device(void)
@@ -366,6 +371,11 @@ void fast_abandon_mutexes( thread_id_t tid )
 {
 }
 
+int fast_user_apc_needs_signal(void)
+{
+    return 0;
+}
+
 #endif
 
 DECL_HANDLER(get_fast_sync_device)
diff --git a/server/object.h b/server/object.h
index 48f7f2d7798..c306a19c719 100644
--- a/server/object.h
+++ b/server/object.h
@@ -233,6 +233,7 @@ extern struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int coun
 extern void fast_set_event( struct fast_sync *obj );
 extern void fast_reset_event( struct fast_sync *obj );
 extern void fast_abandon_mutexes( thread_id_t tid );
+extern int fast_user_apc_needs_signal(void);
 
 extern struct fast_sync *no_get_fast_sync( struct object *obj );
 
diff --git a/server/thread.c b/server/thread.c
index 3b6dedb613f..1e07b386da0 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1136,8 +1136,9 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
     {
         if (thread->state == TERMINATED) return 0;
         queue = get_apc_queue( thread, apc->call.type );
-        /* send signal for system APCs if needed */
-        if (queue == &thread->system_apc && list_empty( queue ) && !is_in_apc_wait( thread ))
+        /* send signal if needed */
+        if ((queue == &thread->system_apc || fast_user_apc_needs_signal())
+            && list_empty( queue ) && !is_in_apc_wait( thread ))
         {
             if (!send_thread_signal( thread, SIGUSR1 )) return 0;
         }
-- 
2.11.4.GIT

From b9f5ec8196964548d69cd4443fb8fe27b29fac64 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 12 Mar 2021 17:23:10 -0600
Subject: [PATCH] ntdll: Do not restart system calls when interrupted with
 SIGUSR1.

---
 dlls/ntdll/unix/signal_arm.c    | 5 +++--
 dlls/ntdll/unix/signal_arm64.c  | 5 +++--
 dlls/ntdll/unix/signal_i386.c   | 5 +++--
 dlls/ntdll/unix/signal_x86_64.c | 5 +++--
 4 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 5c96521e55e..50b6594bb06 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -958,14 +958,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 80cc59d0743..d96c8e2509b 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -1111,8 +1111,6 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = usr2_handler;
     if (sigaction( SIGUSR2, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
@@ -1123,6 +1121,9 @@ void signal_init_process(void)
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = bus_handler;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 655fd69ee73..4b1e3109ab0 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2546,14 +2546,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 7dab5fbf4ed..315956a00e2 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2867,14 +2867,15 @@ void signal_init_process(void)
     if (sigaction( SIGABRT, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = quit_handler;
     if (sigaction( SIGQUIT, &sig_act, NULL ) == -1) goto error;
-    sig_act.sa_sigaction = usr1_handler;
-    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = trap_handler;
     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
     sig_act.sa_sigaction = segv_handler;
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = usr1_handler;
+    sig_act.sa_flags &= ~SA_RESTART; /* needed for fast sync alertable waits */
+    if (sigaction( SIGUSR1, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
-- 
2.11.4.GIT

From 6ddba40d7cc35d6b73970532a4d99b9a1e9fb7a7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 8 Mar 2021 18:07:23 -0600
Subject: [PATCH] ntdll: Introduce a helper to wait on an internal server
 handle.

---
 dlls/ntdll/unix/file.c         |  4 ++--
 dlls/ntdll/unix/process.c      |  2 +-
 dlls/ntdll/unix/server.c       | 17 ++++++++++++++++-
 dlls/ntdll/unix/thread.c       |  2 +-
 dlls/ntdll/unix/unix_private.h |  2 ++
 5 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 233778df3b2..acc900e7393 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -4555,7 +4555,7 @@ static async_data_t server_async( HANDLE handle, struct async_fileio *user, HAND
 
 static NTSTATUS wait_async( HANDLE handle, BOOL alertable, IO_STATUS_BLOCK *io )
 {
-    if (NtWaitForSingleObject( handle, alertable, NULL )) return STATUS_PENDING;
+    if (server_wait_for_object( handle, alertable, NULL )) return STATUS_PENDING;
     return io->u.Status;
 }
 
@@ -5883,7 +5883,7 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index ca9951dfa03..408cf81b6df 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -1013,7 +1013,7 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    NtWaitForSingleObject( process_info, FALSE, NULL );
+    server_wait_for_object( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 506cc99e542..1dd209aa9c4 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -728,6 +728,21 @@ unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT f
 }
 
 
+/* helper function to perform a server-side wait on an internal handle; avoids
+ * using the fast synchronization path */
+unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    select_op.wait.op = SELECT_WAIT;
+    select_op.wait.handles[0] = wine_server_obj_handle( handle );
+    return server_wait( &select_op, offsetof( select_op_t, wait.handles[1] ), flags, timeout );
+}
+
+
 /***********************************************************************
  *              NtContinue  (NTDLL.@)
  */
@@ -778,7 +793,7 @@ unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call, a
         }
         else
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 00d29ae706b..d84cbe1a64a 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -619,7 +619,7 @@ NTSTATUS get_thread_context( HANDLE handle, context_t *context, unsigned int fla
     {
         LARGE_INTEGER timeout;
         timeout.QuadPart = -1000000;
-        if (NtWaitForSingleObject( handle, FALSE, &timeout ))
+        if (server_wait_for_object( handle, FALSE, &timeout ))
         {
             NtClose( handle );
             return STATUS_ACCESS_DENIED;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index b8b6619c0a9..00457b96225 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -147,6 +147,8 @@ extern unsigned int server_select( const select_op_t *select_op, data_size_t siz
                                    user_apc_t *user_apc ) DECLSPEC_HIDDEN;
 extern unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
                                  const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
+extern unsigned int server_wait_for_object( HANDLE handle, BOOL alertable,
+                                            const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
 extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call,
                                               apc_result_t *result ) DECLSPEC_HIDDEN;
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
-- 
2.11.4.GIT

From 458187844188203412f2c7b618b860521150490c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Mar 2021 10:56:27 -0600
Subject: [PATCH] ntdll: Use fast synchronization objects.

---
 dlls/ntdll/unix/server.c       |   2 +-
 dlls/ntdll/unix/sync.c         | 837 +++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/unix_private.h |   1 +
 3 files changed, 839 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 1dd209aa9c4..8eecf49e100 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -349,7 +349,7 @@ static int wait_select_reply( void *cookie )
 }
 
 
-static void invoke_apc( CONTEXT *context, const user_apc_t *apc )
+void invoke_apc( CONTEXT *context, const user_apc_t *apc )
 {
     switch( apc->type )
     {
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 6e08e59174f..21ec8d2a7eb 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -30,8 +30,12 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
 #endif
@@ -61,6 +65,9 @@
 # include <mach/semaphore.h>
 # include <mach/mach_time.h>
 #endif
+#ifdef HAVE_LINUX_WINESYNC_H
+# include <linux/winesync.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -317,6 +324,793 @@ static NTSTATUS validate_open_object_attributes( const OBJECT_ATTRIBUTES *attr )
 }
 
 
+#ifdef HAVE_LINUX_WINESYNC_H
+
+static int get_fast_sync_device(void)
+{
+    static int fast_sync_fd = -2;
+
+    if (fast_sync_fd == -2)
+    {
+        HANDLE device;
+        int fd, needs_close;
+        NTSTATUS ret;
+
+        SERVER_START_REQ( get_fast_sync_device )
+        {
+            if (!(ret = wine_server_call( req ))) device = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            if (!server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL ))
+            {
+                if (InterlockedCompareExchange( &fast_sync_fd, fd, -2 ) != -2)
+                {
+                    /* someone beat us to it */
+                    if (needs_close) close( fd );
+                    NtClose( device );
+                }
+                /* otherwise don't close the device */
+            }
+            else
+            {
+                InterlockedCompareExchange( &fast_sync_fd, -1, -2 );
+                NtClose( device );
+            }
+        }
+        else
+        {
+            InterlockedCompareExchange( &fast_sync_fd, -1, -2 );
+        }
+    }
+    return fast_sync_fd;
+}
+
+/* It's possible for synchronization primitives to remain alive even after being
+ * closed, because a thread is still waiting on them. It's rare in practice, and
+ * documented as being undefined behaviour by Microsoft, but it works, and some
+ * applications rely on it. This means we need to refcount handles, and defer
+ * deleting them on the server side until the refcount reaches zero. We do this
+ * by having each client process hold a handle to the fast synchronization
+ * object, as well as a private refcount. When the client refcount reaches zero,
+ * it closes the handle; when all handles are closed, the server deletes the
+ * fast synchronization object.
+ *
+ * We want lookup of objects from the cache to be very fast; ideally, it should
+ * be lock-free. We achieve this by using atomic modifications to "refcount",
+ * and guaranteeing that all other fields are valid and correct *as long as*
+ * refcount is nonzero, and we store the entire structure in memory which will
+ * never be freed.
+ *
+ * This means that acquiring the object can't use a simple atomic increment; it
+ * has to use a compare-and-swap loop to ensure that it doesn't try to increment
+ * an object with a zero refcount. That's still leagues better than a real lock,
+ * though, and release can be a single atomic decrement.
+ *
+ * It also means that threads modifying the cache need to take a lock, to
+ * prevent other threads from writing to it concurrently.
+ *
+ * It's possible for an object currently in use (by a waiter) to be closed and
+ * the same handle immediately reallocated to a different object. This should be
+ * a very rare situation, and in that case we simply don't cache the handle.
+ */
+struct fast_sync_cache_entry
+{
+    int refcount;
+    int obj;
+    enum fast_sync_type type;
+    unsigned int access;
+    BOOL closed;
+    /* handle to the underlying fast sync object, stored as obj_handle_t to save
+     * space */
+    obj_handle_t handle;
+};
+
+
+static void release_fast_sync_obj( struct fast_sync_cache_entry *cache )
+{
+    /* save the handle now; as soon as the refcount hits 0 we cannot access the
+     * cache anymore */
+    HANDLE handle = wine_server_ptr_handle( cache->handle );
+    int refcount = InterlockedDecrement( &cache->refcount );
+
+    assert( refcount >= 0 );
+
+    if (!refcount)
+    {
+        NTSTATUS ret = NtClose( handle );
+        assert( !ret );
+    }
+}
+
+
+/* returns a pointer to a cache entry; if the object could not be cached,
+ * returns "fallback_cache" instead, which should be allocated on stack */
+static NTSTATUS get_fast_sync_obj( HANDLE handle, enum fast_sync_type desired_type, ACCESS_MASK desired_access,
+                                   struct fast_sync_cache_entry *fallback_cache,
+                                   struct fast_sync_cache_entry **ret_cache )
+{
+    struct fast_sync_cache_entry *cache = fallback_cache;
+    NTSTATUS ret;
+
+    *ret_cache = fallback_cache;
+
+    SERVER_START_REQ( get_fast_sync_obj )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            cache->handle = reply->handle;
+            cache->access = reply->access;
+            cache->type = reply->type;
+            cache->obj = reply->obj;
+            cache->refcount = 1;
+            cache->closed = FALSE;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (!ret && desired_type && desired_type != cache->type)
+    {
+        release_fast_sync_obj( cache );
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if (!ret && (cache->access & desired_access) != desired_access)
+    {
+        release_fast_sync_obj( cache );
+        return STATUS_ACCESS_DENIED;
+    }
+
+    return ret;
+}
+
+
+static NTSTATUS fast_release_semaphore_obj( int device, int obj, ULONG count, ULONG *prev_count )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    args.count = count;
+    ret = ioctl( device, WINESYNC_IOC_PUT_SEM, &args );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_SEMAPHORE,
+                                  SEMAPHORE_MODIFY_STATE, &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_release_semaphore_obj( device, cache->obj, count, prev_count );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_query_semaphore_obj( int device, int obj, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_SEM, &args );
+
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->CurrentCount = args.count;
+    info->MaximumCount = args.max;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_SEMAPHORE,
+                                  SEMAPHORE_QUERY_STATE, &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_query_semaphore_obj( device, cache->obj, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_set_event_obj( int device, int obj, LONG *prev_state )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    args.count = 1;
+    ret = ioctl( device, WINESYNC_IOC_PUT_SEM, &args );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+        {
+            if (prev_state) *prev_state = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_state) *prev_state = 0;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_set_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_EVENT, EVENT_MODIFY_STATE,
+                                  &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_set_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_reset_event_obj( int device, int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+
+    ret = ioctl( device, WINESYNC_IOC_GET_SEM, &obj );
+    if (ret < 0)
+    {
+        if (errno == EWOULDBLOCK)
+        {
+            if (prev_state) *prev_state = 0;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_state) *prev_state = 1;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_reset_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_EVENT, EVENT_MODIFY_STATE,
+                                  &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_reset_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_pulse_event_obj( int device, int obj, LONG *prev_state )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    args.count = 1;
+    ret = ioctl( device, WINESYNC_IOC_PULSE_SEM, &args );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+        {
+            if (prev_state) *prev_state = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_state) *prev_state = 0;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_EVENT, EVENT_MODIFY_STATE,
+                                  &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_pulse_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_query_event_obj( int device, int obj, EVENT_BASIC_INFORMATION *info )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_SEM, &args );
+
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->EventType = (args.flags & WINESYNC_SEM_GETONWAIT) ? SynchronizationEvent : NotificationEvent;
+    info->EventState = args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_EVENT, EVENT_QUERY_STATE,
+                                  &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_query_event_obj( device, cache->obj, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_release_mutex_obj( int device, int obj, LONG *prev_count )
+{
+    struct winesync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.mutex = obj;
+    args.owner = GetCurrentThreadId();
+    ret = ioctl( device, WINESYNC_IOC_PUT_MUTEX, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_MUTANT_LIMIT_EXCEEDED;
+        else if (errno == EPERM)
+            return STATUS_MUTANT_NOT_OWNED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_MUTEX, 0, &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_release_mutex_obj( device, cache->obj, prev_count );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS fast_query_mutex_obj( int device, int obj, MUTANT_BASIC_INFORMATION *info )
+{
+    struct winesync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.mutex = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_MUTEX, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOWNERDEAD)
+        {
+            info->AbandonedState = TRUE;
+            info->OwnedByCaller = FALSE;
+            info->CurrentCount = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    info->AbandonedState = FALSE;
+    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
+    info->CurrentCount = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry fallback_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_MUTEX, MUTANT_QUERY_STATE,
+                                  &fallback_cache, &cache )))
+        return ret;
+
+    ret = fast_query_mutex_obj( device, cache->obj, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+struct timespec64
+{
+    __s64 tv_sec;
+    __s64 tv_nsec;
+};
+
+static void timespec64_from_timeout( struct timespec64 *timespec, const LARGE_INTEGER *timeout )
+{
+    struct timespec now;
+    timeout_t relative;
+
+    if (clock_gettime( CLOCK_MONOTONIC_COARSE, &now ) < 0)
+        clock_gettime( CLOCK_MONOTONIC, &now );
+
+    if (timeout->QuadPart <= 0)
+    {
+        relative = -timeout->QuadPart;
+    }
+    else
+    {
+        LARGE_INTEGER system_now;
+
+        /* the system clock is probably REALTIME, so we need to convert to
+         * relative time first */
+        NtQuerySystemTime( &system_now );
+        relative = timeout->QuadPart - system_now.QuadPart;
+    }
+
+    timespec->tv_sec = now.tv_sec + (relative / TICKSPERSEC);
+    timespec->tv_nsec = now.tv_nsec + ((relative % TICKSPERSEC) * 100);
+    if (timespec->tv_nsec >= 1000000000)
+    {
+        timespec->tv_nsec -= 1000000000;
+        ++timespec->tv_sec;
+    }
+}
+
+static void select_queue( HANDLE queue )
+{
+    SERVER_START_REQ( fast_select_queue )
+    {
+        req->handle = wine_server_obj_handle( queue );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static void unselect_queue( HANDLE queue, BOOL signaled )
+{
+    SERVER_START_REQ( fast_unselect_queue )
+    {
+        req->handle = wine_server_obj_handle( queue );
+        req->signaled = signaled;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static NTSTATUS fast_wait_objs( int device, DWORD count, const int *objs, BOOLEAN wait_any,
+                                BOOLEAN alertable, const LARGE_INTEGER *timeout, user_apc_t *apc )
+{
+    struct winesync_wait_args args = {0};
+    struct timespec64 timespec;
+    uintptr_t timeout_ptr = 0;
+    unsigned long request;
+    NTSTATUS ret;
+
+    if (timeout && timeout->QuadPart != TIMEOUT_INFINITE)
+    {
+        timeout_ptr = (uintptr_t)&timespec;
+        timespec64_from_timeout( &timespec, timeout );
+    }
+    args.objs = (uintptr_t)objs;
+    args.count = count;
+    args.owner = GetCurrentThreadId();
+
+    if (wait_any || count == 1)
+        request = WINESYNC_IOC_WAIT_ANY;
+    else
+        request = WINESYNC_IOC_WAIT_ALL;
+
+    if (alertable)
+    {
+        struct timespec64 now64;
+        struct timespec now;
+
+        /* if there is an already signaled object and an APC available, the
+         * object is returned first */
+        if (clock_gettime( CLOCK_MONOTONIC_COARSE, &now ) < 0)
+            clock_gettime( CLOCK_MONOTONIC, &now );
+        now64.tv_sec = now.tv_sec;
+        now64.tv_nsec = now.tv_nsec;
+        args.timeout = (uintptr_t)&now64;
+        ret = ioctl( device, request, &args );
+
+        if (ret < 0 && errno == ETIMEDOUT)
+        {
+            args.timeout = timeout_ptr;
+            do
+            {
+                ret = server_select( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE,
+                                     0, NULL, NULL, apc );
+                if (ret == STATUS_USER_APC)
+                    return STATUS_USER_APC;
+
+                ret = ioctl( device, request, &args );
+
+                /* if we got interrupted, it might have been to deliver a user
+                 * APC, so check if there are any available again */
+            } while (ret < 0 && errno == EINTR);
+        }
+    }
+    else
+    {
+        args.timeout = timeout_ptr;
+        do
+        {
+            ret = ioctl( device, request, &args );
+        } while (ret < 0 && errno == EINTR);
+    }
+
+    if (!ret)
+        return wait_any ? args.index : 0;
+    else if (errno == EOWNERDEAD)
+        return STATUS_ABANDONED + (wait_any ? args.index : 0);
+    else if (errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return errno_to_status( errno );
+}
+
+static NTSTATUS fast_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                           BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct fast_sync_cache_entry fallback_cache[64], *cache[64];
+    int objs[64], device;
+    HANDLE queue = NULL;
+    user_apc_t apc;
+    NTSTATUS ret;
+    DWORD i, j;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (i = 0; i < count; ++i)
+    {
+        if ((ret = get_fast_sync_obj( handles[i], 0, SYNCHRONIZE, &fallback_cache[i], &cache[i] )))
+        {
+            for (j = 0; j < i; ++j)
+                release_fast_sync_obj( cache[j] );
+            return ret;
+        }
+        if (cache[i]->type == FAST_SYNC_QUEUE)
+            queue = handles[i];
+
+        objs[i] = cache[i]->obj;
+    }
+
+    if (queue) select_queue( queue );
+
+    ret = fast_wait_objs( device, count, objs, wait_any, alertable, timeout, &apc );
+
+    if (queue) unselect_queue( queue, handles[ret] == queue );
+
+    for (i = 0; i < count; ++i)
+        release_fast_sync_obj( cache[i] );
+
+    if (ret == STATUS_USER_APC)
+        invoke_apc( NULL, &apc );
+    return ret;
+}
+
+static NTSTATUS fast_signal_and_wait( HANDLE signal, HANDLE wait,
+                                      BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct fast_sync_cache_entry signal_fallback_cache, *signal_cache;
+    struct fast_sync_cache_entry wait_fallback_cache, *wait_cache;
+    HANDLE queue = NULL;
+    user_apc_t apc;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_fast_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( signal, 0, 0, &signal_fallback_cache, &signal_cache )))
+        return ret;
+
+    switch (signal_cache->type)
+    {
+        case FAST_SYNC_SEMAPHORE:
+            if (!(signal_cache->access & SEMAPHORE_MODIFY_STATE))
+            {
+                release_fast_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case FAST_SYNC_EVENT:
+            if (!(signal_cache->access & EVENT_MODIFY_STATE))
+            {
+                release_fast_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case FAST_SYNC_MUTEX:
+            break;
+
+        default:
+            /* can't be signaled */
+            release_fast_sync_obj( signal_cache );
+            return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((ret = get_fast_sync_obj( wait, 0, SYNCHRONIZE, &wait_fallback_cache, &wait_cache )))
+    {
+        release_fast_sync_obj( signal_cache );
+        return ret;
+    }
+
+    if (wait_cache->type == FAST_SYNC_QUEUE)
+        queue = wait;
+
+    switch (signal_cache->type)
+    {
+        case FAST_SYNC_SEMAPHORE:
+            ret = fast_release_semaphore_obj( device, signal_cache->obj, 1, NULL );
+            break;
+
+        case FAST_SYNC_EVENT:
+            ret = fast_set_event_obj( device, signal_cache->obj, NULL );
+            break;
+
+        case FAST_SYNC_MUTEX:
+            ret = fast_release_mutex_obj( device, signal_cache->obj, NULL );
+            break;
+
+        default:
+            assert( 0 );
+            break;
+    }
+
+    if (!ret)
+    {
+        if (queue) select_queue( queue );
+
+        ret = fast_wait_objs( device, 1, &wait_cache->obj, TRUE, alertable, timeout, &apc );
+
+        if (queue) unselect_queue( queue, !ret );
+    }
+
+    release_fast_sync_obj( signal_cache );
+    release_fast_sync_obj( wait_cache );
+
+    if (ret == STATUS_USER_APC)
+        invoke_apc( NULL, &apc );
+    return ret;
+}
+
+#else
+
+static NTSTATUS fast_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_set_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_reset_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                           BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS fast_signal_and_wait( HANDLE signal, HANDLE wait,
+                                      BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
  */
@@ -394,6 +1188,12 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -418,6 +1218,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 
     TRACE( "handle %p, count %u, prev_count %p\n", handle, count, previous );
 
+    if ((ret = fast_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -499,6 +1302,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -520,6 +1326,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -551,6 +1360,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -583,6 +1395,12 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_event )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -663,6 +1481,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 
     TRACE( "handle %p, prev_count %p\n", handle, prev_count );
 
+    if ((ret = fast_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -693,6 +1514,12 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1475,6 +2302,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
     }
 
+    if ((ret = fast_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    {
+        TRACE( "-> %#x\n", ret );
+        return ret;
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
@@ -1501,11 +2334,15 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 {
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
+    if ((ret = fast_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 00457b96225..5529fe28a19 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -139,6 +139,7 @@ extern NTSTATUS exec_wineloader( char **argv, int socketfd, const pe_image_info_
 extern void start_server( BOOL debug ) DECLSPEC_HIDDEN;
 extern ULONG_PTR get_image_address(void) DECLSPEC_HIDDEN;
 
+extern void invoke_apc( CONTEXT *context, const user_apc_t *apc ) DECLSPEC_HIDDEN;
 extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
 extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
 extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
-- 
2.11.4.GIT

From bbe30babfaed633394f0ec975d20a9d33900e329 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 12 Mar 2021 15:04:17 -0600
Subject: [PATCH] ntdll: Cache fast synchronization objects.

---
 dlls/ntdll/unix/server.c       |   3 +
 dlls/ntdll/unix/sync.c         | 183 ++++++++++++++++++++++++++++++++++++++---
 dlls/ntdll/unix/unix_private.h |   2 +
 3 files changed, 177 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 8eecf49e100..6229fc201e1 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1737,6 +1737,7 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
     {
         fd = remove_fd_from_cache( source );
         if (fd != -1) close( fd );
+        close_fast_sync_obj( source );
     }
 
     SERVER_START_REQ( dup_handle )
@@ -1769,6 +1770,8 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
      * retrieve it again */
     int fd = remove_fd_from_cache( handle );
 
+    close_fast_sync_obj( handle );
+
     SERVER_START_REQ( close_handle )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 21ec8d2a7eb..45671b72711 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -36,6 +36,9 @@
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
 #endif
@@ -378,6 +381,12 @@ static int get_fast_sync_device(void)
  * it closes the handle; when all handles are closed, the server deletes the
  * fast synchronization object.
  *
+ * We also need this for signal-and-wait. The signal and wait operations aren't
+ * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
+ * for the wait—we need to either do both operations or neither. That means we
+ * need to grab references to both objects, and prevent them from being
+ * destroyed before we're done with them.
+ *
  * We want lookup of objects from the cache to be very fast; ideally, it should
  * be lock-free. We achieve this by using atomic modifications to "refcount",
  * and guaranteeing that all other fields are valid and correct *as long as*
@@ -425,6 +434,120 @@ static void release_fast_sync_obj( struct fast_sync_cache_entry *cache )
     }
 }
 
+static pthread_mutex_t fast_sync_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+
+#define FAST_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct fast_sync_cache_entry))
+#define FAST_SYNC_CACHE_ENTRIES     128
+
+static struct fast_sync_cache_entry *fast_sync_cache[FAST_SYNC_CACHE_ENTRIES];
+static struct fast_sync_cache_entry fast_sync_cache_initial_block[FAST_SYNC_CACHE_BLOCK_SIZE];
+
+static inline unsigned int handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / FAST_SYNC_CACHE_BLOCK_SIZE;
+    return idx % FAST_SYNC_CACHE_BLOCK_SIZE;
+}
+
+
+static struct fast_sync_cache_entry *cache_fast_sync_obj( HANDLE handle, obj_handle_t fast_sync, int obj,
+                                                          enum fast_sync_type type, unsigned int access )
+{
+    unsigned int entry, idx = handle_to_index( handle, &entry );
+    struct fast_sync_cache_entry *cache;
+    int refcount;
+
+    if (entry >= FAST_SYNC_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return NULL;
+    }
+
+    if (!fast_sync_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) fast_sync_cache[0] = fast_sync_cache_initial_block;
+        else
+        {
+            static const size_t size = FAST_SYNC_CACHE_BLOCK_SIZE * sizeof(struct fast_sync_cache_entry *);
+            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return NULL;
+            if (InterlockedCompareExchangePointer( (void **)&fast_sync_cache[entry], ptr, NULL ))
+                munmap( ptr, size ); /* someone beat us to it */
+        }
+    }
+
+    cache = &fast_sync_cache[entry][idx];
+
+    mutex_lock( &fast_sync_cache_mutex );
+
+    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
+    {
+        /* We lost the race with another thread trying to cache this object, or
+         * the handle is currently being used for another object (i.e. it was
+         * closed and then reused). We have no way of knowing which, and in the
+         * latter case we can't cache this object until the old one is
+         * completely destroyed, so always return failure. */
+        mutex_unlock( &fast_sync_cache_mutex );
+        return NULL;
+    }
+
+    cache->handle = fast_sync;
+    cache->obj = obj;
+    cache->type = type;
+    cache->access = access;
+    cache->closed = FALSE;
+    /* make sure we set the other members before the refcount; this store needs
+     * release semantics
+     * set the refcount to 2 (one for the handle, one for the caller) */
+    refcount = InterlockedExchange( &cache->refcount, 2 );
+    assert( !refcount );
+
+    mutex_unlock( &fast_sync_cache_mutex );
+
+    return cache;
+}
+
+
+/* returns the previous value */
+static inline LONG interlocked_inc_if_nonzero( LONG *dest )
+{
+    LONG val, tmp;
+    for (val = *dest;; val = tmp)
+    {
+        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
+            break;
+    }
+    return val;
+}
+
+
+static struct fast_sync_cache_entry *get_cached_fast_sync_obj( HANDLE handle )
+{
+    unsigned int entry, idx = handle_to_index( handle, &entry );
+    struct fast_sync_cache_entry *cache;
+
+    if (entry >= FAST_SYNC_CACHE_ENTRIES || !fast_sync_cache[entry])
+        return NULL;
+
+    cache = &fast_sync_cache[entry][idx];
+
+    /* this load needs acquire semantics */
+    if (!interlocked_inc_if_nonzero( &cache->refcount ))
+        return NULL;
+
+    if (cache->closed)
+    {
+        /* The object is still being used, but the handle has been closed.
+         * It might have been reused for another object in the meantime, so
+         * force the caller to check the server. */
+        InterlockedDecrement( &cache->refcount );
+        return NULL;
+    }
+
+    return cache;
+}
+
 
 /* returns a pointer to a cache entry; if the object could not be cached,
  * returns "fallback_cache" instead, which should be allocated on stack */
@@ -432,39 +555,77 @@ static NTSTATUS get_fast_sync_obj( HANDLE handle, enum fast_sync_type desired_ty
                                    struct fast_sync_cache_entry *fallback_cache,
                                    struct fast_sync_cache_entry **ret_cache )
 {
-    struct fast_sync_cache_entry *cache = fallback_cache;
+    struct fast_sync_cache_entry *cache;
+    obj_handle_t fast_sync_handle;
+    enum fast_sync_type type;
+    unsigned int access;
     NTSTATUS ret;
+    int obj;
 
-    *ret_cache = fallback_cache;
+    /* try to find it in the cache already */
+    if ((cache = get_cached_fast_sync_obj( handle )))
+    {
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
 
+    /* try to retrieve it from the server */
     SERVER_START_REQ( get_fast_sync_obj )
     {
         req->handle = wine_server_obj_handle( handle );
         if (!(ret = wine_server_call( req )))
         {
-            cache->handle = reply->handle;
-            cache->access = reply->access;
-            cache->type = reply->type;
-            cache->obj = reply->obj;
-            cache->refcount = 1;
-            cache->closed = FALSE;
+            fast_sync_handle = reply->handle;
+            access = reply->access;
+            type = reply->type;
+            obj = reply->obj;
         }
     }
     SERVER_END_REQ;
 
-    if (!ret && desired_type && desired_type != cache->type)
+    if (ret) return ret;
+
+    cache = cache_fast_sync_obj( handle, fast_sync_handle, obj, type, access );
+    if (!cache)
+    {
+        cache = fallback_cache;
+        cache->handle = fast_sync_handle;
+        cache->obj = obj;
+        cache->type = type;
+        cache->access = access;
+        cache->closed = FALSE;
+        cache->refcount = 1;
+    }
+
+    *ret_cache = cache;
+
+    if (desired_type && desired_type != cache->type)
     {
         release_fast_sync_obj( cache );
         return STATUS_OBJECT_TYPE_MISMATCH;
     }
 
-    if (!ret && (cache->access & desired_access) != desired_access)
+    if ((cache->access & desired_access) != desired_access)
     {
         release_fast_sync_obj( cache );
         return STATUS_ACCESS_DENIED;
     }
 
-    return ret;
+    return STATUS_SUCCESS;
+}
+
+
+void close_fast_sync_obj( HANDLE handle )
+{
+    struct fast_sync_cache_entry *cache = get_cached_fast_sync_obj( handle );
+
+    if (cache)
+    {
+        cache->closed = TRUE;
+        /* once for the reference we just grabbed, and once for the handle */
+        release_fast_sync_obj( cache );
+        release_fast_sync_obj( cache );
+    }
 }
 
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 5529fe28a19..e4af55ffd92 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -241,6 +241,8 @@ extern void init_cpu_info(void) DECLSPEC_HIDDEN;
 
 extern void dbg_init(void) DECLSPEC_HIDDEN;
 
+extern void close_fast_sync_obj( HANDLE handle ) DECLSPEC_HIDDEN;
+
 extern void WINAPI DECLSPEC_NORETURN call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR ctx,
                                                                ULONG_PTR arg1, ULONG_PTR arg2,
                                                                PNTAPCFUNC func,
-- 
2.11.4.GIT

From 0d67ba2147a4a74ab511ef0254913e0bed6602f8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 26 Jun 2018 18:44:44 -0500
Subject: [PATCH] kernel32/tests: Zigzag test.

The primary function is to check for races. The secondary function is to measure performance.
---
 dlls/kernel32/tests/sync.c | 79 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 79 insertions(+)

diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index f1c5f01fa84..f33dfd3f56c 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -2747,6 +2747,84 @@ static void test_QueueUserAPC(void)
     CloseHandle(thread);
 }
 
+static int zigzag_state, zigzag_count[2], zigzag_stop;
+
+static DWORD CALLBACK zigzag_event0(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[0], INFINITE);
+        ResetEvent(events[0]);
+        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
+        zigzag_state++;
+        SetEvent(events[1]);
+        zigzag_count[0]++;
+    }
+    trace("thread 0 got done\n");
+    return 0;
+}
+
+static DWORD CALLBACK zigzag_event1(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[1], INFINITE);
+        ResetEvent(events[1]);
+        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
+        zigzag_state--;
+        SetEvent(events[0]);
+        zigzag_count[1]++;
+    }
+    trace("thread 1 got done\n");
+    return 0;
+}
+
+static void test_zigzag_event(void)
+{
+    /* The basic idea is to test SetEvent/Wait back and forth between two
+     * threads. Each thread clears their own event, sets some common data,
+     * signals the other's, then waits on their own. We make sure the common
+     * data is always in the right state. We also print performance data. */
+
+    HANDLE threads[2], events[2];
+    BOOL ret;
+
+    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
+    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
+    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
+
+    zigzag_state = 0;
+    zigzag_count[0] = zigzag_count[1] = 0;
+    zigzag_stop = 0;
+
+    trace("starting zigzag test (events)\n");
+    SetEvent(events[0]);
+    Sleep(2000);
+    zigzag_stop = 1;
+    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
+    trace("%d\n", ret);
+    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
+
+    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
+        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
+
+    /* signal the other thread to finish, if it didn't already
+     * (in theory they both would at the same time, but there's a slight race on teardown if we get
+     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
+    zigzag_state = 1-ret;
+    SetEvent(events[1-ret]);
+    ret = WaitForSingleObject(threads[1-ret], 1000);
+    ok(!ret, "wait failed: %u\n", ret);
+
+    trace("count: %d\n", zigzag_count[0]);
+}
+
 START_TEST(sync)
 {
     char **argv;
@@ -2811,5 +2889,6 @@ START_TEST(sync)
     test_srwlock_example();
     test_alertable_wait();
     test_apc_deadlock();
+    test_zigzag_event();
     test_crit_section();
 }
-- 
2.11.4.GIT

From ed00ce37e46b712f1ffe90838681587df244b72e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Fri, 12 Mar 2021 18:27:36 -0600
Subject: [PATCH] make_req

---
 include/wine/server_protocol.h | 100 +++++++++++++++++++++++++++++++++++++++--
 server/request.h               |  27 +++++++++--
 server/trace.c                 |  47 ++++++++++++++++++-
 3 files changed, 165 insertions(+), 9 deletions(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 18551a2d448..90afd91e7ba 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -467,6 +467,7 @@ enum apc_type
     APC_MAP_VIEW,
     APC_UNMAP_VIEW,
     APC_CREATE_THREAD,
+    APC_DUP_HANDLE,
     APC_BREAK_PROCESS
 };
 
@@ -577,6 +578,15 @@ typedef union
         mem_size_t       reserve;
         mem_size_t       commit;
     } create_thread;
+    struct
+    {
+        enum apc_type    type;
+        obj_handle_t     src_handle;
+        obj_handle_t     dst_process;
+        unsigned int     access;
+        unsigned int     attributes;
+        unsigned int     options;
+    } dup_handle;
 } apc_call_t;
 
 typedef union
@@ -668,6 +678,12 @@ typedef union
     {
         enum apc_type    type;
         unsigned int     status;
+        obj_handle_t     handle;
+    } dup_handle;
+    struct
+    {
+        enum apc_type    type;
+        unsigned int     status;
     } break_process;
 } apc_result_t;
 
@@ -1255,9 +1271,7 @@ struct dup_handle_reply
 {
     struct reply_header __header;
     obj_handle_t handle;
-    int          self;
-    int          closed;
-    char __pad_20[4];
+    char __pad_12[4];
 };
 
 
@@ -5388,6 +5402,72 @@ struct resume_process_reply
 };
 
 
+enum fast_sync_type
+{
+    FAST_SYNC_SEMAPHORE = 1,
+    FAST_SYNC_MUTEX,
+    FAST_SYNC_EVENT,
+    FAST_SYNC_SERVER,
+    FAST_SYNC_QUEUE,
+};
+
+
+
+struct get_fast_sync_device_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_fast_sync_device_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
+
+
+struct get_fast_sync_obj_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_fast_sync_obj_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          obj;
+    int          type;
+    unsigned int access;
+};
+
+
+
+struct fast_select_queue_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct fast_select_queue_reply
+{
+    struct reply_header __header;
+};
+
+
+
+struct fast_unselect_queue_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          signaled;
+    char __pad_20[4];
+};
+struct fast_unselect_queue_reply
+{
+    struct reply_header __header;
+};
+
+
 enum request
 {
     REQ_new_process,
@@ -5664,6 +5744,10 @@ enum request
     REQ_terminate_job,
     REQ_suspend_process,
     REQ_resume_process,
+    REQ_get_fast_sync_device,
+    REQ_get_fast_sync_obj,
+    REQ_fast_select_queue,
+    REQ_fast_unselect_queue,
     REQ_NB_REQUESTS
 };
 
@@ -5945,6 +6029,10 @@ union generic_request
     struct terminate_job_request terminate_job_request;
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
+    struct get_fast_sync_device_request get_fast_sync_device_request;
+    struct get_fast_sync_obj_request get_fast_sync_obj_request;
+    struct fast_select_queue_request fast_select_queue_request;
+    struct fast_unselect_queue_request fast_unselect_queue_request;
 };
 union generic_reply
 {
@@ -6224,11 +6312,15 @@ union generic_reply
     struct terminate_job_reply terminate_job_reply;
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
+    struct get_fast_sync_device_reply get_fast_sync_device_reply;
+    struct get_fast_sync_obj_reply get_fast_sync_obj_reply;
+    struct fast_select_queue_reply fast_select_queue_reply;
+    struct fast_unselect_queue_reply fast_unselect_queue_reply;
 };
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 684
+#define SERVER_PROTOCOL_VERSION 685
 
 /* ### protocol_version end ### */
 
diff --git a/server/request.h b/server/request.h
index 23308ed49e6..7268716965d 100644
--- a/server/request.h
+++ b/server/request.h
@@ -393,6 +393,10 @@ DECL_HANDLER(get_job_info);
 DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
+DECL_HANDLER(get_fast_sync_device);
+DECL_HANDLER(get_fast_sync_obj);
+DECL_HANDLER(fast_select_queue);
+DECL_HANDLER(fast_unselect_queue);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -673,6 +677,10 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_terminate_job,
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
+    (req_handler)req_get_fast_sync_device,
+    (req_handler)req_get_fast_sync_obj,
+    (req_handler)req_fast_select_queue,
+    (req_handler)req_fast_unselect_queue,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -879,9 +887,7 @@ C_ASSERT( FIELD_OFFSET(struct dup_handle_request, attributes) == 28 );
 C_ASSERT( FIELD_OFFSET(struct dup_handle_request, options) == 32 );
 C_ASSERT( sizeof(struct dup_handle_request) == 40 );
 C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, handle) == 8 );
-C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, self) == 12 );
-C_ASSERT( FIELD_OFFSET(struct dup_handle_reply, closed) == 16 );
-C_ASSERT( sizeof(struct dup_handle_reply) == 24 );
+C_ASSERT( sizeof(struct dup_handle_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct make_temporary_request, handle) == 12 );
 C_ASSERT( sizeof(struct make_temporary_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct open_process_request, pid) == 12 );
@@ -2237,6 +2243,21 @@ C_ASSERT( FIELD_OFFSET(struct suspend_process_request, handle) == 12 );
 C_ASSERT( sizeof(struct suspend_process_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct resume_process_request, handle) == 12 );
 C_ASSERT( sizeof(struct resume_process_request) == 16 );
+C_ASSERT( sizeof(struct get_fast_sync_device_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_device_reply, handle) == 8 );
+C_ASSERT( sizeof(struct get_fast_sync_device_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_obj_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_fast_sync_obj_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_obj_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_obj_reply, obj) == 12 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_obj_reply, type) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_sync_obj_reply, access) == 20 );
+C_ASSERT( sizeof(struct get_fast_sync_obj_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct fast_select_queue_request, handle) == 12 );
+C_ASSERT( sizeof(struct fast_select_queue_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct fast_unselect_queue_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct fast_unselect_queue_request, signaled) == 16 );
+C_ASSERT( sizeof(struct fast_unselect_queue_request) == 24 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index f7c792b326d..4f2aa7bbf46 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1687,8 +1687,6 @@ static void dump_dup_handle_request( const struct dup_handle_request *req )
 static void dump_dup_handle_reply( const struct dup_handle_reply *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
-    fprintf( stderr, ", self=%d", req->self );
-    fprintf( stderr, ", closed=%d", req->closed );
 }
 
 static void dump_make_temporary_request( const struct make_temporary_request *req )
@@ -4462,6 +4460,39 @@ static void dump_resume_process_request( const struct resume_process_request *re
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_get_fast_sync_device_request( const struct get_fast_sync_device_request *req )
+{
+}
+
+static void dump_get_fast_sync_device_reply( const struct get_fast_sync_device_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_fast_sync_obj_request( const struct get_fast_sync_obj_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_fast_sync_obj_reply( const struct get_fast_sync_obj_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", obj=%d", req->obj );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", access=%08x", req->access );
+}
+
+static void dump_fast_select_queue_request( const struct fast_select_queue_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_fast_unselect_queue_request( const struct fast_unselect_queue_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", signaled=%d", req->signaled );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_exec_process_request,
@@ -4737,6 +4768,10 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_terminate_job_request,
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
+    (dump_func)dump_get_fast_sync_device_request,
+    (dump_func)dump_get_fast_sync_obj_request,
+    (dump_func)dump_fast_select_queue_request,
+    (dump_func)dump_fast_unselect_queue_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5014,6 +5049,10 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     NULL,
+    (dump_func)dump_get_fast_sync_device_reply,
+    (dump_func)dump_get_fast_sync_obj_reply,
+    NULL,
+    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5291,6 +5330,10 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "terminate_job",
     "suspend_process",
     "resume_process",
+    "get_fast_sync_device",
+    "get_fast_sync_obj",
+    "fast_select_queue",
+    "fast_unselect_queue",
 };
 
 static const struct
-- 
2.11.4.GIT

From 479f559d75f7c7385b216c33fd070a1890cdf6b7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 13 Mar 2021 16:20:30 -0600
Subject: [PATCH] server: Allow disabling fast synchronization support.

---
 server/fast_sync.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 834a8d9e6b6..698c1a24229 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -127,6 +127,12 @@ static struct fast_sync_device *get_fast_sync_device(void)
     struct fast_sync_device *device;
     int unix_fd;
 
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return NULL;
+    }
+
     if (fast_sync_device_object)
         return (struct fast_sync_device *)grab_object( fast_sync_device_object );
 
-- 
2.11.4.GIT

 
